{"meta":{"title":"Dylan","subtitle":null,"description":"本博客专注于ASIC数字电路相关知识,提供优质的技术文章","author":"董续胜","url":"https://dxsm.github.io","root":"/"},"pages":[{"title":"","date":"2021-06-10T15:14:58.303Z","updated":"2021-06-10T15:14:58.303Z","comments":true,"path":"googlef475f9fdeb00ac53.html","permalink":"https://dxsm.github.io/googlef475f9fdeb00ac53.html","excerpt":"","text":"google-site-verification: googlef475f9fdeb00ac53.html"},{"title":"关于我","date":"2019-08-10T08:41:10.000Z","updated":"2021-12-04T17:53:28.410Z","comments":true,"path":"about/index.html","permalink":"https://dxsm.github.io/about/index.html","excerpt":"","text":"教育经历 硕士 电路与系统专业 电子科技大学 联系方式 电子邮箱 959229640@qq.com 地址 上海浦东新区 QQ 959229640"},{"title":"archives","date":"2019-08-10T08:39:20.000Z","updated":"2021-06-10T14:38:28.652Z","comments":true,"path":"archives/index.html","permalink":"https://dxsm.github.io/archives/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2018-10-22T08:10:46.000Z","updated":"2021-12-05T10:26:36.987Z","comments":false,"path":"categories/index.html","permalink":"https://dxsm.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言版","date":"2019-08-05T09:17:02.000Z","updated":"2021-12-04T17:54:27.440Z","comments":true,"path":"contact/index.html","permalink":"https://dxsm.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 博客名称: Dylan 博客网址: https://dxsm.github.io 博客头像: https://cdn.jsdelivr.net/gh/dxsm/cdn/images/avatar3.jpg 博客介绍: 专注于ASIC设计，Python经验分享"},{"title":"相册","date":"2021-06-10T14:38:28.652Z","updated":"2021-06-10T14:38:28.652Z","comments":true,"path":"galleries/index.html","permalink":"https://dxsm.github.io/galleries/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-02-13T12:25:59.000Z","updated":"2021-06-10T14:38:28.652Z","comments":false,"path":"links/index.html","permalink":"https://dxsm.github.io/links/index.html","excerpt":"","text":""},{"title":"在线书籍","date":"2019-02-13T12:25:59.000Z","updated":"2021-06-10T14:38:28.652Z","comments":false,"path":"list/books.html","permalink":"https://dxsm.github.io/list/books.html","excerpt":"","text":""},{"title":"在线小游戏","date":"2019-02-13T12:25:59.000Z","updated":"2021-06-10T14:38:28.652Z","comments":false,"path":"list/games.html","permalink":"https://dxsm.github.io/list/games.html","excerpt":"","text":""},{"title":"在线书籍","date":"2019-02-13T12:25:59.000Z","updated":"2021-06-10T14:38:28.652Z","comments":false,"path":"list/index.html","permalink":"https://dxsm.github.io/list/index.html","excerpt":"","text":""},{"title":"在线工具","date":"2019-02-13T12:25:59.000Z","updated":"2021-12-01T16:56:58.660Z","comments":false,"path":"list/tools.html","permalink":"https://dxsm.github.io/list/tools.html","excerpt":"","text":""},{"title":"说说","date":"2019-02-13T12:25:59.000Z","updated":"2021-06-10T14:38:28.652Z","comments":true,"path":"shuoshuo/index.html","permalink":"https://dxsm.github.io/shuoshuo/index.html","excerpt":"","text":"说点什么吧！！！"},{"title":"文章标签","date":"2018-10-22T08:11:42.000Z","updated":"2021-12-05T10:26:55.365Z","comments":false,"path":"tags/index.html","permalink":"https://dxsm.github.io/tags/index.html","excerpt":"","text":""},{"title":"背景图片3","date":"2021-06-10T14:38:28.652Z","updated":"2021-06-10T14:38:28.652Z","comments":true,"path":"galleries/背景图片3/index.html","permalink":"https://dxsm.github.io/galleries/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%873/index.html","excerpt":"","text":""},{"title":"背景图片4","date":"2021-06-10T14:38:28.652Z","updated":"2021-06-10T14:38:28.652Z","comments":true,"path":"galleries/背景图片4/index.html","permalink":"https://dxsm.github.io/galleries/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%874/index.html","excerpt":"","text":""}],"posts":[{"title":"SpinalHDL基础-例化与传参","slug":"SpinalHDL_inst","date":"2021-09-26T12:43:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/spinalhdl-inst.html","link":"","permalink":"https://dxsm.github.io/p/spinalhdl-inst.html","excerpt":"","text":"1、传参 SpinalHDLVerilogclass adder(width: Int = 8) extends Module { val io = new Bundle { val a = in UInt(width bits) val b = in UInt(width bits) val sum = out UInt(width bits) } io.sum := io.a + io.b } class top extends Module { val adder0 = new adder(16) val adder1 = new adder(32) } module top ( ); wire [15:0] adder0_io_a; wire [15:0] adder0_io_b; wire [31:0] adder1_io_a; wire [31:0] adder1_io_b; wire [15:0] adder0_io_sum; wire [31:0] adder1_io_sum; adder adder0 ( .io_a (adder0_io_a[15:0] ), //i .io_b (adder0_io_b[15:0] ), //i .io_sum (adder0_io_sum[15:0] ) //o ); adder_1 adder1 ( .io_a (adder1_io_a[31:0] ), //i .io_b (adder1_io_b[31:0] ), //i .io_sum (adder1_io_sum[31:0] ) //o ); endmodule module adder_1 ( input [31:0] io_a, input [31:0] io_b, output [31:0] io_sum ); assign io_sum = (io_a + io_b); endmodule module adder ( input [15:0] io_a, input [15:0] io_b, output [15:0] io_sum ); assign io_sum = (io_a + io_b); endmodule","categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"}]},{"title":"SpinalHDL基础-数组","slug":"SpinalHDL_array","date":"2021-09-25T11:23:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/spinalhdl-array.html","link":"","permalink":"https://dxsm.github.io/p/spinalhdl-array.html","excerpt":"1、二位数组 SpinalHDLVerilogclass top extends Module { val para_buf = Vec(UInt(8 bits),4) para_buf(0) := 1 para_buf(1) := 2 para_buf(2) := 3 para_buf(3) := 4 } module top ( ); wire [7:0] para_buf_0; wire [7:0] para_buf_1; wire [7:0] para_buf_2; wire [7:0] para_buf_3; assign para_buf_0 = 8'h01; assign para_buf_1 = 8'h02; assign para_buf_2 = 8'h03; assign para_buf_3 = 8'h04; endmodule","text":"1、二位数组 SpinalHDLVerilogclass top extends Module { val para_buf = Vec(UInt(8 bits),4) para_buf(0) := 1 para_buf(1) := 2 para_buf(2) := 3 para_buf(3) := 4 } module top ( ); wire [7:0] para_buf_0; wire [7:0] para_buf_1; wire [7:0] para_buf_2; wire [7:0] para_buf_3; assign para_buf_0 = 8'h01; assign para_buf_1 = 8'h02; assign para_buf_2 = 8'h03; assign para_buf_3 = 8'h04; endmodule 2、三维数组 SpinalHDLVerilogclass top extends Module { val para_buf = Vec(Vec(UInt(8 bits),4),2) para_buf(0)(0) := 1 para_buf(1)(0) := 2 para_buf(0)(1) := 3 para_buf(1)(1) := 4 para_buf(0)(2) := 5 para_buf(1)(2) := 6 para_buf(0)(3) := 7 para_buf(1)(3) := 8 } module top ( ); wire [7:0] para_buf_0_0; wire [7:0] para_buf_0_1; wire [7:0] para_buf_0_2; wire [7:0] para_buf_0_3; wire [7:0] para_buf_1_0; wire [7:0] para_buf_1_1; wire [7:0] para_buf_1_2; wire [7:0] para_buf_1_3; assign para_buf_0_0 = 8'h01; assign para_buf_1_0 = 8'h02; assign para_buf_0_1 = 8'h03; assign para_buf_1_1 = 8'h04; assign para_buf_0_2 = 8'h05; assign para_buf_1_2 = 8'h06; assign para_buf_0_3 = 8'h07; assign para_buf_1_3 = 8'h08; endmodule 3、for循环 SpinalHDLVerilogclass top extends Module { val para_buf = Vec(UInt(8 bits),4) for(element &lt;- para_buf) { element := 0 } val data_buf = Vec(UInt(8 bits),4) // for(i &lt;- 0 until data_buf.size) { for(i &lt;- data_buf.indices) { //idea建议使用indices data_buf(i) := i + 1 } } module top ( ); wire [7:0] para_buf_0; wire [7:0] para_buf_1; wire [7:0] para_buf_2; wire [7:0] para_buf_3; wire [7:0] data_buf_0; wire [7:0] data_buf_1; wire [7:0] data_buf_2; wire [7:0] data_buf_3; assign para_buf_0 = 8'h0; assign para_buf_1 = 8'h0; assign para_buf_2 = 8'h0; assign para_buf_3 = 8'h0; assign data_buf_0 = 8'h01; assign data_buf_1 = 8'h02; assign data_buf_2 = 8'h03; assign data_buf_3 = 8'h04; endmodule 4、map函数 SpinalHDLVerilogclass top extends Module { val para_buf = Vec(UInt(8 bits),4) para_buf.map(_ := 0) } module top ( ); wire [7:0] para_buf_0; wire [7:0] para_buf_1; wire [7:0] para_buf_2; wire [7:0] para_buf_3; assign para_buf_0 = 8'h0; assign para_buf_1 = 8'h0; assign para_buf_2 = 8'h0; assign para_buf_3 = 8'h0; endmodule","categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"}]},{"title":"SpinalHDL基础-BlackBox","slug":"SpinalHDL_blackbox","date":"2021-09-24T12:23:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/spinalhdl-blackbox.html","link":"","permalink":"https://dxsm.github.io/p/spinalhdl-blackbox.html","excerpt":"1、外联RTL SpinalHDLVerilogclass adder(width: Int) extends BlackBox { addGeneric(\"WIDTH\", width) val io = new Bundle { val ain = in UInt(width bits) val bin = in UInt(width bits) val add_out = out UInt(width bits) } noIoPrefix() addRTLPath(\"rtl/adder.v\") } class top extends Module { val io = new Bundle { val ain = in UInt(16 bits) val bin = in UInt(16 bits) val add_out = out UInt(16 bits) } noIoPrefix() var adder0 = new adder(16) io.ain &lt;> adder0.io.ain io.bin &lt;> adder0.io.bin io.add_out &lt;> adder0.io.add_out } module top ( input [15:0] ain, input [15:0] bin, output [15:0] add_out ); wire [15:0] adder0_add_out; adder #( .WIDTH(16) ) adder0 ( .ain (ain[15:0] ), //i .bin (bin[15:0] ), //i .add_out (adder0_add_out[15:0] ) //o ); assign add_out = adder0_add_out; endmodule","text":"1、外联RTL SpinalHDLVerilogclass adder(width: Int) extends BlackBox { addGeneric(\"WIDTH\", width) val io = new Bundle { val ain = in UInt(width bits) val bin = in UInt(width bits) val add_out = out UInt(width bits) } noIoPrefix() addRTLPath(\"rtl/adder.v\") } class top extends Module { val io = new Bundle { val ain = in UInt(16 bits) val bin = in UInt(16 bits) val add_out = out UInt(16 bits) } noIoPrefix() var adder0 = new adder(16) io.ain &lt;> adder0.io.ain io.bin &lt;> adder0.io.bin io.add_out &lt;> adder0.io.add_out } module top ( input [15:0] ain, input [15:0] bin, output [15:0] add_out ); wire [15:0] adder0_add_out; adder #( .WIDTH(16) ) adder0 ( .ain (ain[15:0] ), //i .bin (bin[15:0] ), //i .add_out (adder0_add_out[15:0] ) //o ); assign add_out = adder0_add_out; endmodule 2、内联RTL SpinalHDLadder.vtop.vclass adder(width: Int) extends BlackBox { addGeneric(\"WIDTH\", width) val io = new Bundle { val ain = in UInt(width bits) val bin = in UInt(width bits) val add_out = out UInt(width bits) } noIoPrefix() setInlineVerilog( \"\"\"module adder #( | parameter WIDTH = 16 |) ( | input [WIDTH-1:0] ain , | input [WIDTH-1:0] bin , | output reg [WIDTH-1:0] add_out |); | |always @(*) begin | add_out = ain + bin; |end | |endmodule \"\"\".stripMargin) } class top extends Module { val io = new Bundle { val ain = in UInt(16 bits) val bin = in UInt(16 bits) val add_out = out UInt(16 bits) } noIoPrefix() var adder0 = new adder(16) io.ain &lt;> adder0.io.ain io.bin &lt;> adder0.io.bin io.add_out &lt;> adder0.io.add_out } module adder #( parameter WIDTH = 16 ) ( input [WIDTH-1:0] ain , input [WIDTH-1:0] bin , output reg [WIDTH-1:0] add_out ); always @(*) begin add_out = ain + bin; end endmodule module top ( input [15:0] ain, input [15:0] bin, output [15:0] add_out ); wire [15:0] adder0_add_out; adder #( .WIDTH(16) ) adder0 ( .ain (ain[15:0] ), //i .bin (bin[15:0] ), //i .add_out (adder0_add_out[15:0] ) //o ); assign add_out = adder0_add_out; endmodule","categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"}]},{"title":"SpinalHDL基础-跨时钟域","slug":"SpinalHDL_clockdomain","date":"2021-09-23T10:35:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/spinalhdl-clockdomain.html","link":"","permalink":"https://dxsm.github.io/p/spinalhdl-clockdomain.html","excerpt":"1、自定义时钟域 SpinalHDLVerilogclass top extends Module{ val io = new Bundle { val clk_a = in Bool() val rst_a_n = in Bool() val clk_b = in Bool() val rst_b_n = in Bool() } noIoPrefix() //1、创建clockDomain val cd_a = ClockDomain(io.clk_a, io.rst_a_n, config = ClockDomainConfig(resetActiveLevel = LOW)) val cd_b = ClockDomain(io.clk_b, io.rst_b_n, config = ClockDomainConfig(resetActiveLevel = LOW)) //2、clockDomain a logic val cnt_a = cd_a on UInt(8 bits) setAsReg() init 0 val wr_en_a = cd_a on Bool() when(wr_en_a) { cnt_a := cnt_a + 1 } val cnt_a_gray = toGray(cnt_a) //3、clockDomain b logic val cnt_b = cd_b on UInt(8 bits) setAsReg() init 0 val wr_en_b = cd_b on Bool() when(wr_en_b) { cnt_b := cnt_b + 1 } //4、clockDomain cross logic val cnt_a2b = cd_b on RegNext(cnt_a_gray) init 0 addTag(crossClockDomain) val cnt_a2b_sync1 = cd_b on RegNext(cnt_a2b) init 0 val cnt_a2b_sync2 = cd_b on RegNext(cnt_a2b_sync1) init 0 } module top ( input clk_a, input rst_a_n, input clk_b, input rst_b_n ); wire [7:0] cnt_a_gray_bits; reg [7:0] cnt_a; wire wr_en_a; wire [7:0] cnt_a_gray; reg [7:0] cnt_b; wire wr_en_b; (* async_reg = \"true\" *) reg [7:0] cnt_a2b; reg [7:0] cnt_a2b_sync1; reg [7:0] cnt_a2b_sync2; assign cnt_a_gray_bits = (cnt_a >>> 1'b1); assign cnt_a_gray = (cnt_a_gray_bits ^ cnt_a); always @(posedge clk_a or negedge rst_a_n) begin if(!rst_a_n) begin cnt_a &lt;= 8'h0; end else begin if(wr_en_a) begin cnt_a &lt;= (cnt_a + 8'h01); end end end always @(posedge clk_b or negedge rst_b_n) begin if(!rst_b_n) begin cnt_b &lt;= 8'h0; cnt_a2b &lt;= 8'h0; cnt_a2b_sync1 &lt;= 8'h0; cnt_a2b_sync2 &lt;= 8'h0; end else begin if(wr_en_b) begin cnt_b &lt;= (cnt_b + 8'h01); end cnt_a2b &lt;= cnt_a_gray; cnt_a2b_sync1 &lt;= cnt_a2b; cnt_a2b_sync2 &lt;= cnt_a2b_sync1; end end endmodule","text":"1、自定义时钟域 SpinalHDLVerilogclass top extends Module{ val io = new Bundle { val clk_a = in Bool() val rst_a_n = in Bool() val clk_b = in Bool() val rst_b_n = in Bool() } noIoPrefix() //1、创建clockDomain val cd_a = ClockDomain(io.clk_a, io.rst_a_n, config = ClockDomainConfig(resetActiveLevel = LOW)) val cd_b = ClockDomain(io.clk_b, io.rst_b_n, config = ClockDomainConfig(resetActiveLevel = LOW)) //2、clockDomain a logic val cnt_a = cd_a on UInt(8 bits) setAsReg() init 0 val wr_en_a = cd_a on Bool() when(wr_en_a) { cnt_a := cnt_a + 1 } val cnt_a_gray = toGray(cnt_a) //3、clockDomain b logic val cnt_b = cd_b on UInt(8 bits) setAsReg() init 0 val wr_en_b = cd_b on Bool() when(wr_en_b) { cnt_b := cnt_b + 1 } //4、clockDomain cross logic val cnt_a2b = cd_b on RegNext(cnt_a_gray) init 0 addTag(crossClockDomain) val cnt_a2b_sync1 = cd_b on RegNext(cnt_a2b) init 0 val cnt_a2b_sync2 = cd_b on RegNext(cnt_a2b_sync1) init 0 } module top ( input clk_a, input rst_a_n, input clk_b, input rst_b_n ); wire [7:0] cnt_a_gray_bits; reg [7:0] cnt_a; wire wr_en_a; wire [7:0] cnt_a_gray; reg [7:0] cnt_b; wire wr_en_b; (* async_reg = \"true\" *) reg [7:0] cnt_a2b; reg [7:0] cnt_a2b_sync1; reg [7:0] cnt_a2b_sync2; assign cnt_a_gray_bits = (cnt_a >>> 1'b1); assign cnt_a_gray = (cnt_a_gray_bits ^ cnt_a); always @(posedge clk_a or negedge rst_a_n) begin if(!rst_a_n) begin cnt_a &lt;= 8'h0; end else begin if(wr_en_a) begin cnt_a &lt;= (cnt_a + 8'h01); end end end always @(posedge clk_b or negedge rst_b_n) begin if(!rst_b_n) begin cnt_b &lt;= 8'h0; cnt_a2b &lt;= 8'h0; cnt_a2b_sync1 &lt;= 8'h0; cnt_a2b_sync2 &lt;= 8'h0; end else begin if(wr_en_b) begin cnt_b &lt;= (cnt_b + 8'h01); end cnt_a2b &lt;= cnt_a_gray; cnt_a2b_sync1 &lt;= cnt_a2b; cnt_a2b_sync2 &lt;= cnt_a2b_sync1; end end endmodule 2、ClockingArea SpinalHDLVerilogclass top extends Module{ val io = new Bundle { val clk_a = in Bool() val rst_a_n = in Bool() val clk_b = in Bool() val rst_b_n = in Bool() } noIoPrefix() //1、创建clockDomain val cd_a = ClockDomain(io.clk_a, io.rst_a_n, config = ClockDomainConfig(resetActiveLevel = LOW)) val cd_b = ClockDomain(io.clk_b, io.rst_b_n, config = ClockDomainConfig(resetActiveLevel = LOW)) //2、clockDomain a logic val a = new ClockingArea(cd_a) { val cnt = UInt(8 bits) setAsReg() init 0 val wr_en = Bool() when(wr_en) { cnt := cnt + 1 } val cnt_gray = toGray(cnt) } //3、clockDomain b logic val b = new ClockingArea(cd_b) { val cnt = UInt(8 bits) setAsReg() init 0 val wr_en = Bool() when(wr_en) { cnt := cnt + 1 } //4、clockDomain cross logic val cnt_sync = RegNext(a.cnt_gray) init 0 addTag (crossClockDomain) val cnt_sync1 = RegNext(cnt_sync) init 0 val cnt_sync2 = RegNext(cnt_sync1) init 0 } } module top ( input clk_a, input rst_a_n, input clk_b, input rst_b_n ); wire [7:0] a_cnt_gray_bits; reg [7:0] a_cnt; wire a_wr_en; wire [7:0] a_cnt_gray; reg [7:0] b_cnt; wire b_wr_en; (* async_reg = \"true\" *) reg [7:0] b_cnt_sync; reg [7:0] b_cnt_sync1; reg [7:0] b_cnt_sync2; assign a_cnt_gray_bits = (a_cnt >>> 1'b1); assign a_cnt_gray = (a_cnt_gray_bits ^ a_cnt); always @(posedge clk_a or negedge rst_a_n) begin if(!rst_a_n) begin a_cnt &lt;= 8'h0; end else begin if(a_wr_en) begin a_cnt &lt;= (a_cnt + 8'h01); end end end always @(posedge clk_b or negedge rst_b_n) begin if(!rst_b_n) begin b_cnt &lt;= 8'h0; b_cnt_sync &lt;= 8'h0; b_cnt_sync1 &lt;= 8'h0; b_cnt_sync2 &lt;= 8'h0; end else begin if(b_wr_en) begin b_cnt &lt;= (b_cnt + 8'h01); end b_cnt_sync &lt;= a_cnt_gray; b_cnt_sync1 &lt;= b_cnt_sync; b_cnt_sync2 &lt;= b_cnt_sync1; end end endmodule","categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"}]},{"title":"SpinalHDL基础-状态机枚举","slug":"SpinalHDL_enum","date":"2021-09-22T12:35:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/spinalhdl-enum.html","link":"","permalink":"https://dxsm.github.io/p/spinalhdl-enum.html","excerpt":"1、Enum SpinalHDLVerilogclass top extends Module{ val io = new Bundle { val start = in Bool() } object mainState extends SpinalEnum { val IDLE,TX_DATA,DONE = newElement() rawElementName() //状态机名去掉object名字前缀 } val cstate = mainState() setAsReg() init(mainState.IDLE) val nstate = mainState() val cnt = Reg(UInt(5 bits)) init(0) when(io.start) { cnt := 0 } elsewhen(cstate === mainState.TX_DATA) { cnt := cnt + 1 } cstate := nstate switch(cstate) { is(mainState.IDLE) { when(io.start) { nstate := mainState.TX_DATA } otherwise { nstate := cstate } } is(mainState.TX_DATA) { when(cnt === U\"5'd31\") { nstate := mainState.DONE } otherwise { nstate := cstate } } is(mainState.DONE) { nstate := mainState.IDLE } } } module top ( input io_start, input clk, input rstn ); localparam IDLE = 2'd0; localparam TX_DATA = 2'd1; localparam DONE = 2'd2; reg [1:0] cstate; reg [1:0] nstate; reg [4:0] cnt; always @(*) begin case(cstate) IDLE : begin if(io_start) begin nstate = TX_DATA; end else begin nstate = cstate; end end TX_DATA : begin if((cnt == 5'h1f)) begin nstate = DONE; end else begin nstate = cstate; end end default : begin nstate = IDLE; end endcase end always @(posedge clk or negedge rstn) begin if(!rstn) begin cstate &lt;= IDLE; cnt &lt;= 5'h0; end else begin if(io_start) begin cnt &lt;= 5'h0; end else begin if((cstate == TX_DATA)) begin cnt &lt;= (cnt + 5'h01); end end cstate &lt;= nstate; end end endmodule","text":"1、Enum SpinalHDLVerilogclass top extends Module{ val io = new Bundle { val start = in Bool() } object mainState extends SpinalEnum { val IDLE,TX_DATA,DONE = newElement() rawElementName() //状态机名去掉object名字前缀 } val cstate = mainState() setAsReg() init(mainState.IDLE) val nstate = mainState() val cnt = Reg(UInt(5 bits)) init(0) when(io.start) { cnt := 0 } elsewhen(cstate === mainState.TX_DATA) { cnt := cnt + 1 } cstate := nstate switch(cstate) { is(mainState.IDLE) { when(io.start) { nstate := mainState.TX_DATA } otherwise { nstate := cstate } } is(mainState.TX_DATA) { when(cnt === U\"5'd31\") { nstate := mainState.DONE } otherwise { nstate := cstate } } is(mainState.DONE) { nstate := mainState.IDLE } } } module top ( input io_start, input clk, input rstn ); localparam IDLE = 2'd0; localparam TX_DATA = 2'd1; localparam DONE = 2'd2; reg [1:0] cstate; reg [1:0] nstate; reg [4:0] cnt; always @(*) begin case(cstate) IDLE : begin if(io_start) begin nstate = TX_DATA; end else begin nstate = cstate; end end TX_DATA : begin if((cnt == 5'h1f)) begin nstate = DONE; end else begin nstate = cstate; end end default : begin nstate = IDLE; end endcase end always @(posedge clk or negedge rstn) begin if(!rstn) begin cstate &lt;= IDLE; cnt &lt;= 5'h0; end else begin if(io_start) begin cnt &lt;= 5'h0; end else begin if((cstate == TX_DATA)) begin cnt &lt;= (cnt + 5'h01); end end cstate &lt;= nstate; end end endmodule 2、全局enum SpinalHDLVerilogclass top extends Module{ val io = new Bundle { val start = in Bool() } object mainState extends SpinalEnum { val IDLE,TX_DATA,DONE = newElement() setGlobal() } val cstate = mainState() setAsReg() init(mainState.IDLE) val nstate = mainState() val cnt = Reg(UInt(5 bits)) init(0) when(io.start) { cnt := 0 } elsewhen(cstate === mainState.TX_DATA) { cnt := cnt + 1 } cstate := nstate switch(cstate) { is(mainState.IDLE) { when(io.start) { nstate := mainState.TX_DATA } otherwise { nstate := cstate } } is(mainState.TX_DATA) { when(cnt === U\"5'd31\") { nstate := mainState.DONE } otherwise { nstate := cstate } } is(mainState.DONE) { nstate := mainState.IDLE } } } `define mainState_IDLE 2'b00 `define mainState_TX_DATA 2'b01 `define mainState_DONE 2'b10 module top ( input io_start, input clk, input rstn ); reg [1:0] cstate; reg [1:0] nstate; reg [4:0] cnt; always @(*) begin case(cstate) `mainState_IDLE : begin if(io_start) begin nstate = `mainState_TX_DATA; end else begin nstate = cstate; end end `mainState_TX_DATA : begin if((cnt == 5'h1f)) begin nstate = `mainState_DONE; end else begin nstate = cstate; end end default : begin nstate = `mainState_IDLE; end endcase end always @(posedge clk or negedge rstn) begin if(!rstn) begin cstate &lt;= `mainState_IDLE; cnt &lt;= 5'h0; end else begin if(io_start) begin cnt &lt;= 5'h0; end else begin if((cstate == `mainState_TX_DATA)) begin cnt &lt;= (cnt + 5'h01); end end cstate &lt;= nstate; end end endmodule","categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"}]},{"title":"SpinalHDL基础-算术与移位运算","slug":"SpinalHDL_algorithm","date":"2021-09-21T11:15:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/spinalhdl-algorithm.html","link":"","permalink":"https://dxsm.github.io/p/spinalhdl-algorithm.html","excerpt":"1、无符号数——运算 SpinalHDLVerilogclass top extends Module{ val a = UInt(5 bits) val b = UInt(8 bits) val res1 = a + b + 1 val res2 = a - b - 1 val res3 = a * b } module top ( ); wire [4:0] a; wire [7:0] b; wire [7:0] res1; wire [7:0] res2; wire [12:0] res3; assign res1 = (({3'd0, a} + b) + 8'h01); assign res2 = (({3'd0, a} - b) - 8'h01); assign res3 = (a * b); endmodule","text":"1、无符号数——运算 SpinalHDLVerilogclass top extends Module{ val a = UInt(5 bits) val b = UInt(8 bits) val res1 = a + b + 1 val res2 = a - b - 1 val res3 = a * b } module top ( ); wire [4:0] a; wire [7:0] b; wire [7:0] res1; wire [7:0] res2; wire [12:0] res3; assign res1 = (({3'd0, a} + b) + 8'h01); assign res2 = (({3'd0, a} - b) - 8'h01); assign res3 = (a * b); endmodule 2、无符号数——常数移位 SpinalHDLVerilogclass top extends Module{ val a = UInt(8 bits) val res1 = a >> 2 //n-2 bits val res2 = a &lt;&lt; 2 //n+2 bits val res3 = a |>> 2 //n bits val res4 = a |&lt;&lt; 2 //n bits } module top ( ); wire [7:0] a; wire [5:0] res1; wire [9:0] res2; wire [7:0] res3; wire [7:0] res4; assign res1 = (a >>> 2); assign res2 = ({2'd0,a} &lt;&lt;&lt; 2); assign res3 = (a >>> 2); assign res4 = (a &lt;&lt;&lt; 2); endmodule 3、无符号数——变量移位 SpinalHDLVerilogclass top extends Module{ val a = UInt(8 bits) val shift_bit = UInt(2 bits) val res1 = a >> shift_bit //n bits val res2 = a &lt;&lt; shift_bit //n+max(shift) bits val res3 = a |>> shift_bit //n bits val res4 = a |&lt;&lt; shift_bit //n bits } module top ( ); wire [7:0] a; wire [1:0] shift_bit; wire [7:0] res1; wire [10:0] res2; wire [7:0] res3; wire [7:0] res4; assign res1 = (a >>> shift_bit); assign res2 = ({3'd0,a} &lt;&lt;&lt; shift_bit); assign res3 = (a >>> shift_bit); assign res4 = (a &lt;&lt;&lt; shift_bit); endmodule 4、有符号数——运算 SpinalHDLVerilogclass top extends Module{ val a = SInt(5 bits) val b = SInt(8 bits) val res1 = a + b + 1 val res2 = a - b - 1 val res3 = a * b } module top ( ); wire [4:0] a; wire [7:0] b; wire [7:0] res1; wire [7:0] res2; wire [12:0] res3; assign res1 = (({ {3{a[4]}}, a} + b) + 8'h01); assign res2 = (({ {3{a[4]}}, a} - b) - 8'h01); assign res3 = ($signed(a) * $signed(b)); endmodule 5、有符号数——常数移位 SpinalHDLVerilogclass top extends Module{ val a = SInt(8 bits) val res1 = a >> 2 //n-2 bits val res2 = a &lt;&lt; 2 //n+2 bits val res3 = a |>> 2 //n bits val res4 = a |&lt;&lt; 2 //n bits } module top ( ); wire [7:0] a; wire [5:0] res1; wire [9:0] res2; wire [7:0] res3; wire [7:0] res4; assign res1 = (a >>> 2); assign res2 = ({2'd0,a} &lt;&lt;&lt; 2); assign res3 = ($signed(a) >>> 2); assign res4 = (a &lt;&lt;&lt; 2); endmodule 6、有符号数——变量移位 SpinalHDLVerilogclass top extends Module{ val a = SInt(8 bits) val shift_bit = UInt(2 bits) val res1 = a >> shift_bit //n bits val res2 = a &lt;&lt; shift_bit //n+max(shift) bits val res3 = a |>> shift_bit //n bits val res4 = a |&lt;&lt; shift_bit //n bits } module top ( ); wire [7:0] a; wire [1:0] shift_bit; wire [7:0] res1; wire [10:0] res2; wire [7:0] res3; wire [7:0] res4; assign res1 = ($signed(a) >>> shift_bit); assign res2 = ({ {3{a[7]}},a} &lt;&lt;&lt; shift_bit); assign res3 = ($signed(a) >>> shift_bit); assign res4 = ($signed(a) &lt;&lt;&lt; shift_bit); endmodule","categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"}]},{"title":"SpinalHDL基础-时序逻辑","slug":"SpinalHDL_sequential","date":"2021-09-20T11:00:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/spinalhdl-sequential.html","link":"","permalink":"https://dxsm.github.io/p/spinalhdl-sequential.html","excerpt":"1、Reg寄存器 SpinalHDLVerilogclass top extends Module{ //方式1 val a = Reg(UInt(8 bits)) a := 3 //方式2 val b = UInt(8 bits) setAsReg() b := a } module top ( input clk, input rstn ); reg [7:0] a; reg [7:0] b; always @(posedge clk) begin a &lt;= 8'h03; b &lt;= a; end endmodule","text":"1、Reg寄存器 SpinalHDLVerilogclass top extends Module{ //方式1 val a = Reg(UInt(8 bits)) a := 3 //方式2 val b = UInt(8 bits) setAsReg() b := a } module top ( input clk, input rstn ); reg [7:0] a; reg [7:0] b; always @(posedge clk) begin a &lt;= 8'h03; b &lt;= a; end endmodule 2、带复位的寄存器 SpinalHDLVerilogclass top extends Module{ //方式1 val a = Reg(Bits(8 bits)) init(0) a := 3 //方式2 val b = RegInit(B(1,8 bits)) b := a //方式3b val c = Bits(8 bits) setAsReg() init 0 c := b } module top ( input clk, input rstn ); reg [7:0] a; reg [7:0] b; reg [7:0] c; always @(posedge clk or negedge rstn) begin if(!rstn) begin a &lt;= 8'h0; b &lt;= 8'h01; c &lt;= 8'h0; end else begin a &lt;= 8'h03; b &lt;= a; c &lt;= b; end end endmodule 改为上升沿复位 SpinalHDLVerilogSpinalConfig(mode = Verilog, defaultConfigForClockDomains = ClockDomainConfig(resetKind = ASYNC, clockEdge = RISING, resetActiveLevel = HIGH)) .generate(new top()) module top ( input clk, input rst ); reg [7:0] a; reg [7:0] b; reg [7:0] c; always @(posedge clk or posedge rst) begin if(rst) begin a &lt;= 8'h0; b &lt;= 8'h01; c &lt;= 8'h0; end else begin a &lt;= 8'h03; b &lt;= a; c &lt;= b; end end endmodule 3、寄存器打拍 SpinalHDLVerilogclass top extends Module{ val a = Reg(Bits(8 bits)) init(0) a := 3 val b = RegNext(a) //带复位的打拍 val c = RegNext(a) init(0) //带条件的打拍 val en = Bool() val d = RegNextWhen(a,en &amp;&amp; a.xorR) } module top ( input clk, input rstn ); reg [7:0] a; reg [7:0] b; reg [7:0] c; wire en; reg [7:0] d; always @(posedge clk or negedge rstn) begin if(!rstn) begin a &lt;= 8'h0; c &lt;= 8'h0; end else begin a &lt;= 8'h03; c &lt;= a; end end always @(posedge clk) begin b &lt;= a; if((en &amp;&amp; (^a))) begin d &lt;= a; end end endmodule","categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"}]},{"title":"SpinalHDL基础-条件语句","slug":"SpinalHDL_conditional","date":"2021-09-19T11:40:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/spinalhdl-conditional.html","link":"","permalink":"https://dxsm.github.io/p/spinalhdl-conditional.html","excerpt":"1、条件语句 由于if被scala语言占用了，SpinalHDL使用when…elsewhen…otherwise来用作硬件的条件语句 SpinalHDLVerilogclass top extends Module{ val a,b = UInt(8 bits) val mode = Bits(2 bits) when(a === b) { mode := 0 } elsewhen(a>b) { mode := 1 } otherwise { mode := 2 } } module top ( ); wire [7:0] a; wire [7:0] b; reg [1:0] mode; always @(*) begin if((a == b)) begin mode = 2'b00; end else begin if((b &lt; a)) begin mode = 2'b01; end else begin mode = 2'b10; end end end endmodule","text":"1、条件语句 由于if被scala语言占用了，SpinalHDL使用when…elsewhen…otherwise来用作硬件的条件语句 SpinalHDLVerilogclass top extends Module{ val a,b = UInt(8 bits) val mode = Bits(2 bits) when(a === b) { mode := 0 } elsewhen(a>b) { mode := 1 } otherwise { mode := 2 } } module top ( ); wire [7:0] a; wire [7:0] b; reg [1:0] mode; always @(*) begin if((a == b)) begin mode = 2'b00; end else begin if((b &lt; a)) begin mode = 2'b01; end else begin mode = 2'b10; end end end endmodule 2、三元操作符 SpinalHDL有2种方法实现verilog的en ? a : b，建议使用后2个方法，第一种方法的|容易与逻辑或混淆。复杂条件建议使用when，这样更加清晰。 en ? a | b en ? a otherwise b，推荐 Mux(en,a,b)，推荐 SpinalHDLVerilogclass top extends Module{ val a,b = UInt(8 bits) val mode1 = (a===b) ? B\"2'd0\" | B\"2'd1\" val mode2 = (a===b) ? B\"2'd0\" otherwise B\"2'd1\" val mode3 = Mux(a===b,B\"2'd0\",B\"2'd1\") } module top ( ); wire [7:0] a; wire [7:0] b; wire [1:0] mode1; wire [1:0] mode2; wire [1:0] mode3; assign mode1 = ((a == b) ? 2'b00 : 2'b01); assign mode2 = ((a == b) ? 2'b00 : 2'b01); assign mode3 = ((a == b) ? 2'b00 : 2'b01); endmodule 3、case语句 SpinalHDLVerilogclass top extends Module{ val sel = Bits(2 bits) val mode = Bits(3 bits) switch(sel) { is(0,2) { mode := B\"3'd0\" } is(1) { mode := B\"3'd1\" } default { mode := B\"3'd2\" } } } module top ( ); wire [1:0] sel; reg [2:0] mode; always @(*) begin case(sel) 2'b00, 2'b10 : begin mode = 3'b000; end 2'b01 : begin mode = 3'b001; end default : begin mode = 3'b010; end endcase end endmodule 4、case简写方式 SpinalHDLVerilogclass top extends Module{ val sel = Bits(2 bits) val mode = sel.mux( (0,1) -> B\"3'd0\", 2 -> B\"3'd1\", default -> B\"3'd2\" ) val mode_reg = Reg(UInt(3 bits)) mode_reg.switchAssign(sel)( (0,1) -> U\"3'd0\", 2 -> U\"3'd1\" ) } module top ( input clk, input rstn ); wire [1:0] sel; reg [2:0] mode; reg [2:0] mode_reg; always @(*) begin case(sel) 2'b00, 2'b01 : begin mode = 3'b000; end 2'b10 : begin mode = 3'b001; end default : begin mode = 3'b010; end endcase end always @(posedge clk) begin case(sel) 2'b00, 2'b01 : begin mode_reg &lt;= 3'b000; end 2'b10 : begin mode_reg &lt;= 3'b001; end default : begin end endcase end endmodule 5、等分case SpinalHDLVerilogclass top extends Module{ val sel = UInt(2 bits) val data = Bits(128 bits) // Dividing a wide Bits type into smaller chunks, using a mux: val dataWord1 = sel.muxList(for (index &lt;- 0 until 4) yield (index, data(index*32+32-1 downto index*32))) val dataWord2 = sel.muxList(data.divideIn(4 slices)) // A shorter way to do the same thing: val dataWord3 = data.subdivideIn(32 bits)(sel) } module top ( ); reg [31:0] dataWord3_bits; wire [1:0] sel; wire [127:0] data; reg [31:0] dataWord1; reg [31:0] dataWord2; wire [31:0] dataWord3; always @(*) begin case(sel) 2'b00 : begin dataWord3_bits = data[31 : 0]; end 2'b01 : begin dataWord3_bits = data[63 : 32]; end 2'b10 : begin dataWord3_bits = data[95 : 64]; end default : begin dataWord3_bits = data[127 : 96]; end endcase end always @(*) begin case(sel) 2'b00 : begin dataWord1 = data[31 : 0]; end 2'b01 : begin dataWord1 = data[63 : 32]; end 2'b10 : begin dataWord1 = data[95 : 64]; end default : begin dataWord1 = data[127 : 96]; end endcase end always @(*) begin case(sel) 2'b00 : begin dataWord2 = data[31 : 0]; end 2'b01 : begin dataWord2 = data[63 : 32]; end 2'b10 : begin dataWord2 = data[95 : 64]; end default : begin dataWord2 = data[127 : 96]; end endcase end assign dataWord3 = dataWord3_bits; endmodule 6、casez SpinalHDLVerilogclass top extends Module{ val sel = Bits(4 bits) val mode = Bits(3 bits) switch(sel) { is(M\"---1\") { mode := B\"3'd0\" } is(M\"--1-\") { mode := B\"3'd1\" } is(M\"-1--\") { mode := B\"3'd2\" } default { mode := B\"3'd3\" } } } module top ( ); wire [3:0] sel; reg [2:0] mode; always @(*) begin casez(sel) 4'b???1 : begin mode = 3'b000; end 4'b??1? : begin mode = 3'b001; end 4'b?1?? : begin mode = 3'b010; end default : begin mode = 3'b011; end endcase end endmodule","categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"}]},{"title":"SpinalHDL基础-组合逻辑","slug":"SpinalHDL_base_comb","date":"2021-09-18T11:29:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/spinalhdl-base-comb.html","link":"","permalink":"https://dxsm.github.io/p/spinalhdl-base-comb.html","excerpt":"1、数据类型 SpinalHDL提供了5个基本类型，以及2个可以使用的复合类型。 基本类型：Bool , Bits , UInt用于无符号整数，SInt用于有符号整数、Enum枚举。 复合类型：Bundle和Vec。","text":"1、数据类型 SpinalHDL提供了5个基本类型，以及2个可以使用的复合类型。 基本类型：Bool , Bits , UInt用于无符号整数，SInt用于有符号整数、Enum枚举。 复合类型：Bundle和Vec。 2、逻辑操作 SpinalHDL支持verilog所有的逻辑操作，大部分跟verilog用法一致，只有少量是有差别的 SpinalHDLVerilogclass top extends Module{ val a,b = UInt(8 bits) val en = Bool() val rst_and = a &amp; b val rst_or = a | b val rst_xor = a ^ b val rst_self_not = ~a val rst_self_and = a.andR //自与 val rst_self_or = a.orR //自或 val rst_self_xor = a.xorR //自异或 val rst_not = !en val rst_equal = (a===b) val rst_inequal = (a=/=b) val rst_bigger = (a>=b) //注意Bits()没有比较大小方法 } object main extend App { SpinalVerilog(new top()) } module top ( ); wire [7:0] a; wire [7:0] b; wire en; wire [7:0] rst_and; wire [7:0] rst_or; wire [7:0] rst_xor; wire [7:0] rst_self_not; wire rst_self_and; wire rst_self_or; wire rst_self_xor; wire rst_not; wire rst_equal; wire rst_inequal; wire rst_bigger; assign rst_and = (a &amp; b); assign rst_or = (a | b); assign rst_xor = (a ^ b); assign rst_self_not = (~ a); assign rst_self_and = (&amp;a); assign rst_self_or = (|a); assign rst_self_xor = (^a); assign rst_not = (! en); assign rst_equal = (a == b); assign rst_inequal = (a != b); assign rst_bigger = (b &lt;= a); endmodule 2、赋值（基础） SpinalHDL除了能像verilog一样赋值外，还提供了其他非常丰富的赋值方式 定义时赋值用= 非定义时赋值用:= SpinalHDLVerilogclass top extends Module{ //方法一：先定义后赋值 val rst0 = Bits(8 bits) rst0 := 32 //注意用:= //方法二：定义时赋值，verilog形式的赋值 val rst1 = B(25, 8 bits) val rst2 = B\"8'hFF\" //与verilog一样,d(base10),b(base2),o(base8) val rst3 = B\"1001_0011\" //与verilog一样，_增加可读性 //扩展VHDL赋值方法到verilog，只关注某些bit val rst4 = B(8 bits, default -> True) // \"11111111\" val rst5 = B(8 bits, (7 downto 5) -> B\"101\", 4 -> true, 3 -> True, default -> false) // \"10111000\" //全置0，全置1，不需指定位宽 val a,b = Bits(8 bits) a.clearAll() b.setAll() } module top ( ); wire [7:0] rst0; wire [7:0] rst1; wire [7:0] rst2; wire [7:0] rst3; wire [7:0] rst4; reg [7:0] rst5; wire [7:0] a; wire [7:0] b; wire [7:0] rst5_const; assign rst0 = 8'h20; assign rst1 = 8'h19; assign rst2 = 8'hff; assign rst3 = 8'h93; assign rst4 = 8'hff; assign rst5_const = 8'h0; always @(*) begin rst5 = rst5_const; rst5[7 : 5] = 3'b101; rst5[4] = 1'b1; rst5[3] = 1'b1; end assign a = 8'h0; assign b = 8'hff; endmodule 3、bit操作 不同点： verilog采用的是[]取bit,SpinalHDL采用的是()取bit 范围采用VHDL的downto和scala的to,until SpinalHDLVerilogclass top extends Module{ val a = Bits(8 bits) a(0) := True a(7 downto 1) := B\"7'h7f\" val res1 = a(0) val res2 = a(7 downto 1) //[7:1] val res4 = a(1 to 7) //[7:1] val res3 = a(1 until 7) //[6:1],注意不包含7 } module top ( ); reg [7:0] a; wire res1; wire [6:0] res2; wire [6:0] res4; wire [5:0] res3; wire a_const; assign a_const = 1'b1; always @(*) begin a[0] = a_const; a[7 : 1] = 7'h7f; end assign res1 = a[0]; assign res2 = a[7 : 1]; assign res4 = a[7 : 1]; assign res3 = a[6 : 1]; endmodule 4、拼位 SpinalHDLVerilogclass top extends Module{ val a = Bits(8 bits) val b = Bits(3 bits) val c = Bool() val rst1 = a ## b ## c val rst2 = Cat(a,b,c) //与上面是等价的 val rst3 = a.cat(4) //复制4次自拼接 } module top ( ); wire [7:0] a; wire [2:0] b; wire c; wire [11:0] rst1; wire [11:0] rst2; wire [31:0] rst3; assign rst1 = {a,b,c}; assign rst2 = {a,b,c}; assign rst3 = {4{a}}; endmodule 5、X态与Z态 SpinalHDLVerilogclass top extends Module{ val a = Bits(8 bits) val b = Bits(8 bits) val c = Bool() a.assignDontCare c := b===M\"1---1---\" } showRtl(new top()) module top ( ); wire [7:0] a; wire [7:0] b; wire c; assign a = 8'bxxxxxxxx; assign c = ((b &amp; 8'h88) == 8'h88); endmodule","categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"}]},{"title":"局域网远程连接vmware的linux","slug":"局域网远程连接vmware的linux","date":"2021-08-07T12:59:57.000Z","updated":"2022-04-08T14:26:43.000Z","comments":true,"path":"p/ju-yu-wang-yuan-cheng-lian-jie-vmware-de-linux.html","link":"","permalink":"https://dxsm.github.io/p/ju-yu-wang-yuan-cheng-lian-jie-vmware-de-linux.html","excerpt":"远程linux端配置 首先vmware虚拟机用桥接方式进行启动 进入系统后,输入ifconfig看IP配置，记下IP地址 设置完成后，需要关闭防火墙才能进行访问（没有防火墙的跳过） /etc/init.d/iptables stop #关闭防火墙 /etc/init.d/iptables status #查看防火墙状态 查看是否SSH是否安装启动： /etc/init.d/sshd status #查看状态 /etc/init.d/sshd start #SSH开启 netstat -antp | grep sshd #确认SSH对外端口【默认为22】是否开启","text":"远程linux端配置 首先vmware虚拟机用桥接方式进行启动 进入系统后,输入ifconfig看IP配置，记下IP地址 设置完成后，需要关闭防火墙才能进行访问（没有防火墙的跳过） /etc/init.d/iptables stop #关闭防火墙 /etc/init.d/iptables status #查看防火墙状态 查看是否SSH是否安装启动： /etc/init.d/sshd status #查看状态 /etc/init.d/sshd start #SSH开启 netstat -antp | grep sshd #确认SSH对外端口【默认为22】是否开启 本地PC端配置 安装secureCRT进行远程登录，登录IP地址为远程Linux端IP，端口用默认的22 secureCRT本身不能打开GUI，如果需要打开GUI，可以安装Xmanager，只是命令行操作可以忽略后面步骤。安装完成后运行Xmanager - Passive程序 在secureCRT登录Linux后，输入命令（貌似非必须） export DISPLAY=192.168.1.11:0.0 #192.168.1.11为自己本地PC的IP地址 设置SecureCRT，回话选项-&gt;连接-&gt;端口转发-&gt;远程/X11，选中“转发X11数据包”，并去除对“强制X11鉴权”的选择 在SecureCRT登录的Linux Terminal输入gvim就可以弹出GUI了","categories":[{"name":"linux","slug":"linux","permalink":"https://dxsm.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dxsm.github.io/tags/linux/"}]},{"title":"解决Linux Device or resource busy问题","slug":"解决Linux-Device-or-resource-busy问题","date":"2021-07-11T11:49:08.000Z","updated":"2022-04-08T14:26:32.000Z","comments":true,"path":"p/jie-jue-linux-device-or-resource-busy-wen-ti.html","link":"","permalink":"https://dxsm.github.io/p/jie-jue-linux-device-or-resource-busy-wen-ti.html","excerpt":"","text":"问题 我一般遇到这种情况，是在进行rm -rf dir还未结束的时候，ctrl+C取消了。再次进行rm -rf 的时候就会出现这种情况无法删除了： rm: cannot remove ‘2021-09-23/.nfs0000000680da307e0000074e’: Device or resource busyrm: cannot remove ‘2021-09-23/.nfs000000069ce7333000000752’: Device or resource busy 解决办法 执行lsof命令查看哪些程序在用这个目录 lsof +d &lt;dir> 显示如下: lsof: WARNING: can't stat() fuse.gvfsd-fuse file system /run/user/1005/gvfs Output information may be incomplete. COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME java 428434 root 7w REG 0,45 0 28373237765 2021-09-23/.nfs000000069b2d400500000756 java 428434 root 8w REG 0,45 33591 28402851925 2021-09-23/.nfs000000069cf1205500000757 java 428434 root 9w REG 0,45 0 28402851926 2021-09-23/.nfs000000069cf1205600000758 java 457674 root 7w REG 0,45 16447 28402201392 2021-09-23/.nfs000000069ce7333000000752 java 457674 root 8w REG 0,45 1837922 27931586686 2021-09-23/.nfs0000000680da307e0000074e 然后kill掉这些进程 kill -9 428434 457674","categories":[{"name":"linux","slug":"linux","permalink":"https://dxsm.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dxsm.github.io/tags/linux/"}]},{"title":"无法获得锁 /var/lib/apt/lists/lock - open","slug":"E-无法获得锁","date":"2021-07-10T11:50:15.000Z","updated":"2022-04-08T14:25:50.000Z","comments":true,"path":"p/e-wu-fa-huo-de-suo.html","link":"","permalink":"https://dxsm.github.io/p/e-wu-fa-huo-de-suo.html","excerpt":"","text":"问题 使用sudo apt install xxx出现以下问题： E: 无法获得锁 /var/lib/apt/lists/lock - open (11: 资源暂时不可用)E: 无法对目录 /var/lib/apt/lists/ 加锁E: 无法获得锁 /var/lib/dpkg/lock - open (11: 资源暂时不可用)E: 无法锁定管理目录(/var/lib/dpkg/)，是否有其他进程正占用它？ 解决方案 sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock","categories":[{"name":"linux","slug":"linux","permalink":"https://dxsm.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://dxsm.github.io/tags/linux/"}]},{"title":"标签插件","slug":"tag_plugins","date":"2021-06-18T13:50:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/tag-plugins.html","link":"","permalink":"https://dxsm.github.io/p/tag-plugins.html","excerpt":"文本 带 下划线 的文本 带 着重号 的文本 带 波浪线 的文本 带 删除线 的文本 键盘样式的文本 command + D 密码样式的文本：这里没有验证码 span 彩色文字 在一段话中方便插入各种颜色的标签，包括：红色、黄色、绿色、青色、蓝色、灰色。 超大号文字 文档「开始」页面中的标题部分就是超大号文字。 Volantis A Wonderful Theme for Hexo","text":"文本 带 下划线 的文本 带 着重号 的文本 带 波浪线 的文本 带 删除线 的文本 键盘样式的文本 command + D 密码样式的文本：这里没有验证码 span 彩色文字 在一段话中方便插入各种颜色的标签，包括：红色、黄色、绿色、青色、蓝色、灰色。 超大号文字 文档「开始」页面中的标题部分就是超大号文字。 Volantis A Wonderful Theme for Hexo p 彩色文字 在一段话中方便插入各种颜色的标签，包括：红色、黄色、绿色、青色、蓝色、灰色。 超大号文字 文档「开始」页面中的标题部分就是超大号文字。 Volantis A Wonderful Theme for Hexo note 经典用法 可以在配置文件中设置默认样式，为简单的一句话提供最的简便写法。 note quote 适合引用一段话 note info 默认主题色，适合中性的信息 note warning 默认黄色，适合警告性的信息 note error/danger 默认红色，适合危险性的信息 note done/success 默认绿色，适合正确操作的信息 更多图标 这些都是默认样式，可以手动加上颜色： note bug red 说明还存在的一些故障 note link green 可以放置一些链接 note paperclip blue 放置一些附件链接 note todo 待办事项 note guide clear 可以加上一段向导 note download 可以放置下载链接 note up 可以说明如何进行更新 note undo light 可以说明如何撤销或者回退 note idea 可以放置一些想法 note up 可以放置一些视频 嵌套测试 标题（可选）Windows 10不是為所有人設計,而是為每個人設計嵌套测试： 请坐和放宽，我正在帮你搞定一切… Folding 测试： 点击查看更多 不要说我们没有警告过你我们都有不顺利的时候 Checkbox fsdfsd 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 Radio 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 timeline 2020-07-24 2.6.6 -&gt; 3.0 如果有 hexo-lazyload-image 插件，需要删除并重新安装最新版本，设置 lazyload.isSPA: true。2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 use_cdn: true 则需要删除。2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。2.x 版本的置顶 top: true 改为了 pin: true，并且同样适用于 layout: page 的页面。如果使用了 hexo-offline 插件，建议卸载，3.0 版本默认开启了 pjax 服务。 2020-05-15 2.6.3 -&gt; 2.6.6 不需要额外处理。 2020-04-20 2.6.2 -&gt; 2.6.3 全局搜索 seotitle 并替换为 seo_title。group 组件的索引规则有变，使用 group 组件的文章内，group: group_name 对应的组件名必须是 group_name。group 组件的列表名优先显示文章的 short_title 其次是 title。 tab 栏目1栏目2。。。import os os.system(\"ls\") folding 查看默认打开的折叠框 这是一个默认打开的折叠框。 查看代码测试 import os os.system(\"ls\") 查看列表测试 haha hehe 查看嵌套测试 查看嵌套测试2 查看嵌套测试3 hahaha inlineimage 这是 一段话。 这又是 一段话。 image 添加描述： 每天下课回宿舍的路，没有什么故事。 指定宽度： 指定宽度并添加描述： 每天下课回宿舍的路，没有什么故事。 设置占位背景色： 优化不同宽度浏览的观感","categories":[{"name":"markdown","slug":"markdown","permalink":"https://dxsm.github.io/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://dxsm.github.io/tags/markdown/"}]},{"title":"爆改typora记录","slug":"爆改typora","date":"2020-08-08T12:15:29.000Z","updated":"2022-04-08T14:45:09.000Z","comments":true,"path":"p/bao-gai-typora.html","link":"","permalink":"https://dxsm.github.io/p/bao-gai-typora.html","excerpt":"asar压缩解压缩 安装asar npm install -g asar 解压 对Typora/resources/app/lib.asar解压缩 asar extract 压缩文件 解压文件夹 压缩：如果压缩文件存在，则会被替换 asar pack 文件夹 压缩文件名","text":"asar压缩解压缩 安装asar npm install -g asar 解压 对Typora/resources/app/lib.asar解压缩 asar extract 压缩文件 解压文件夹 压缩：如果压缩文件存在，则会被替换 asar pack 文件夹 压缩文件名 js美化与压缩 安装 npm install uglify-js -g #压缩 npm install js-beautify -g #美化 美化 js-beautify -f input_file_name(js, html, css file) -o output_file_name 压缩 uglifyjs source.js -o target.js 修改内容 meta_block自动添加日期，发博客时就不需要填写日期了，输入---回车试试 增加wavedrom，试试```wavedrom回车试试，效果图 增加kminder，试试```kminder回车试试，效果图","categories":[{"name":"typora","slug":"typora","permalink":"https://dxsm.github.io/categories/typora/"}],"tags":[{"name":"typora","slug":"typora","permalink":"https://dxsm.github.io/tags/typora/"}]},{"title":"low power RTL优化之提高clock gating efficiency","slug":"low power RTL优化之提高CGE","date":"2020-07-05T16:17:21.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/low-power-rtl-you-hua-zhi-ti-gao-cge.html","link":"","permalink":"https://dxsm.github.io/p/low-power-rtl-you-hua-zhi-ti-gao-cge.html","excerpt":"1. block level clock gating 如果某个模块或者功能可以打开或关闭，且logic相对独立，则可以在这部分logic的时钟上加手动插入一个ICG，用模块是能控制ICG的开关，这样能最大限度的提升gating效率。 ICG最好选取驱动能力较大的，以便于驱动足够多的DFF。 ICG建议加一个wrapper,这样当需要替换其他工艺时，只需要将wrapper里的instance 换掉。 综合时对此类ICG设置don’t touch","text":"1. block level clock gating 如果某个模块或者功能可以打开或关闭，且logic相对独立，则可以在这部分logic的时钟上加手动插入一个ICG，用模块是能控制ICG的开关，这样能最大限度的提升gating效率。 ICG最好选取驱动能力较大的，以便于驱动足够多的DFF。 ICG建议加一个wrapper,这样当需要替换其他工艺时，只需要将wrapper里的instance 换掉。 综合时对此类ICG设置don’t touch 2. RTL clock gating Lowpower RTL综合的精髓就是把本该综合在D端的enable信号，综合到CLK端，这样只有enable有效才能释放一个clk使得D端数据传递到Q端。当D超过一定bit数，通常认定&gt;=4bit能节省power, 为了达到这种效果，寄存器的赋值一定是条件赋值，示范代码和电路如下： Low power RTL 理想代码结构： always@(posedge clk or negedge rstn) begin if(!rstn)begin Q&lt;= 'h0; end else if (condition_1)begin Q&lt;= D_1; end //other condition 2, 3, 4 … else begin Q&lt;= Q; //better to remove this assignment, then data willbe kept. end end 错误代码的示例, 如果不管在什么情况下，总有D值需要打到Q, 使得即使综合出来ICG， 该ICG也不能关断。错误远不止下面几种，if/else if/else, case/default 等等 没有赋值条件 always@(posedge clk) begin //”if-else”hierarchy 0, default is “else” block Q &lt;= D; //Error: no condition for Data assignment. end else 赋值 always@(posedge clk or negedge rstn) begin //hier0 if(!rstn) begin //hier1 “if” block Q &lt;=’h0; end else begin //hier1 “else” block Q&lt;=D; //Error: no condition for Dataassignment. end end 多级条件中的else always@(posedge clk or negedge rstn) begin //hier0 if(!rstn) begin //hier1 “if” block Q &lt;=’h0; end else if(condition1) begin //hier1 “else if” block if(condition1_1) begin //hier2“if”block Q&lt;=D1_1; end else begin //hier2“else” block Q&lt;=D1_2; //not report error, as it is in “else if”block. end end else begin //hier1 “else” block if(conditon2_1) begin //hier2“if” block Q&lt;=D2_1; end else begin //hier2“else” block, in hier1 “else” block Q&lt;=D2_2; //Error: no condition for Data assignment. end end end 下面这个例子不会报错 always@(posedge clk or negedge rstn) begin //hier0 if(!rstn)begin //hier1 “if” block Q &lt;=’h0; end else if(condition1) begin //hire1 “else if” block Q&lt;=Q; //”Q&lt;=Q”ensure ICG insertion end else begin //hier1 “else” block Q&lt;=D; //Not reportERROR as “Q&lt;=Q” in “else if”. end end","categories":[{"name":"低功耗设计","slug":"低功耗设计","permalink":"https://dxsm.github.io/categories/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Low Power","slug":"Low-Power","permalink":"https://dxsm.github.io/tags/Low-Power/"}]},{"title":"electron-vue学习之环境搭建","slug":"electron_learning_chp1","date":"2020-07-05T15:40:39.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/electron-learning-chp1.html","link":"","permalink":"https://dxsm.github.io/p/electron-learning-chp1.html","excerpt":"electron-vue环境配置 工作环境centos8，切换到root用户安装npm、yarn、vue_cli yum install npm npm install yarn -g npm install vue_cli -g 切换到工作用户，使用淘宝源下载库更快速 npm config set registry=http://registry.npm.taobao.org yarn config set registry https://registry.npm.taobao.org yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ 使用npm config list和yarn config list查看切换源是否成功","text":"electron-vue环境配置 工作环境centos8，切换到root用户安装npm、yarn、vue_cli yum install npm npm install yarn -g npm install vue_cli -g 切换到工作用户，使用淘宝源下载库更快速 npm config set registry=http://registry.npm.taobao.org yarn config set registry https://registry.npm.taobao.org yarn config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ 使用npm config list和yarn config list查看切换源是否成功 初始化electron_vue项目 #下载模板 vue init simulatedgreg/electron-vue my-project #下载依赖库 yarn #运行 yarn run dev #发行 yarn build 在开发环境搭建的时候需要注意下面俩点： electron-vue 虽然说使用npm也可以下载依赖，但是最好不要用，在我这个版本测试的时候，使用npm下载依赖打包时有问题，总而言之，就是用yarn就好了。 Eslint选择no，testing都选择no，其他默认即可 选择打包工具的时候，选择electron packager，不要选electron builder，builder在打包的时候回从aws上面下载资源，但是我这即使使用了某些不可说的工具，也下载不下来这些资源，会导致打包失败。 安装Element-UI环境 npm install element-ui -S 在src/renderer/main.js添加 // element-ui import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(ElementUI) 修改src/render/components/LandingPage.vue, 下面这一段就是从element官网copy的一段代码, 然后我把它精简了一下, 下面这段代码就当做我们演示element &lt;template&gt; &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;el-menu :default-openeds=&quot;['1', '3']&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header style=&quot;text-align: right; font-size: 12px&quot;&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;el-table :data=&quot;tableData&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;140&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;120&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/template&gt; &lt;script&gt; export default { data() { const item = { date: '2016-05-02', name: '王小虎', address: '上海市普陀区金沙江路 1518 弄' }; return { tableData: Array(5).fill(item) } } }; &lt;/script&gt; &lt;style&gt; .el-header { background-color: #B3C0D1; color: #333; line-height: 60px; } .el-aside { color: #333; } &lt;/style&gt; NaN 然后执行yarn run dev会发现el-table这个表格组件好像很特殊！它怎么都显示不出来，除了它以外其他的控件都能正常显示，根据electron-vue作者自己的回复，element-ui需要加入到白名单里面，需要修改.electron-vue/webpack.renderer.config.js 将： let whiteListedModules = ['vue'] 修改为： let whiteListedModules = ['vue', 'element-ui']","categories":[{"name":"electron","slug":"electron","permalink":"https://dxsm.github.io/categories/electron/"}],"tags":[{"name":"electron","slug":"electron","permalink":"https://dxsm.github.io/tags/electron/"},{"name":"electron-vue","slug":"electron-vue","permalink":"https://dxsm.github.io/tags/electron-vue/"}]},{"title":"jtag工作原理","slug":"jtag","date":"2020-07-05T15:12:44.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/jtag.html","link":"","permalink":"https://dxsm.github.io/p/jtag.html","excerpt":"1. 边界扫描 在JTAG调试当中，边界扫描（Boundary-Scan）是一个很重要的概念。边界扫描技术的基本思想是在靠近芯片的输入输出管脚上增加一个移位寄存器单元。因为这些移位寄存器单元都分布在芯片的边界上（周围），所以被称为边界扫描寄存器（Boundary-Scan Register Cell）。当芯片处于调试状态的时候，这些边界扫描寄存器可以将芯片和外围的输入输出隔离开来。通过这些边界扫描寄存器单元，可以实现对芯片输入输出信号的观察和控制。对于芯片的输入管脚，可以通过与之相连的边界扫描寄存器单元把信号（数据）加载倒该管脚中去；对于芯片的输出管脚，也可以通过与之相连的边界扫描寄存器“捕获”（CAPTURE）该管脚上的输出信号。在正常的运行状态下，这些边界扫描寄存器对芯片来说是透明的，所以正常的运行不会受到任何影响。这样，边界扫描寄存器提供了一个便捷的方式用以观测和控制所需要调试的芯片。另外，芯片输入输出管脚上的边界扫描（移位）寄存器单元可以相互连接起来，在芯片的周围形成一个边界扫描链（Boundary-Scan Chain）。一般的芯片都会提供几条独立的边界扫描链，用来实现完整的测试功能。边界扫描链可以串行的输入和输出，通过相应的时钟信号和控制信号，就可以方便的观察和控制处在调试状态下的芯片。 利用边界扫描链可以实现对芯片的输入输出进行观察和控制。下一个问题是：如何来管理和使用这些边界扫描链？对边界扫描链的控制主要是通过TAP(Test Access Port) Controller来完成的。在下一节，我们一起来看看TAP是如何工作的。","text":"1. 边界扫描 在JTAG调试当中，边界扫描（Boundary-Scan）是一个很重要的概念。边界扫描技术的基本思想是在靠近芯片的输入输出管脚上增加一个移位寄存器单元。因为这些移位寄存器单元都分布在芯片的边界上（周围），所以被称为边界扫描寄存器（Boundary-Scan Register Cell）。当芯片处于调试状态的时候，这些边界扫描寄存器可以将芯片和外围的输入输出隔离开来。通过这些边界扫描寄存器单元，可以实现对芯片输入输出信号的观察和控制。对于芯片的输入管脚，可以通过与之相连的边界扫描寄存器单元把信号（数据）加载倒该管脚中去；对于芯片的输出管脚，也可以通过与之相连的边界扫描寄存器“捕获”（CAPTURE）该管脚上的输出信号。在正常的运行状态下，这些边界扫描寄存器对芯片来说是透明的，所以正常的运行不会受到任何影响。这样，边界扫描寄存器提供了一个便捷的方式用以观测和控制所需要调试的芯片。另外，芯片输入输出管脚上的边界扫描（移位）寄存器单元可以相互连接起来，在芯片的周围形成一个边界扫描链（Boundary-Scan Chain）。一般的芯片都会提供几条独立的边界扫描链，用来实现完整的测试功能。边界扫描链可以串行的输入和输出，通过相应的时钟信号和控制信号，就可以方便的观察和控制处在调试状态下的芯片。 利用边界扫描链可以实现对芯片的输入输出进行观察和控制。下一个问题是：如何来管理和使用这些边界扫描链？对边界扫描链的控制主要是通过TAP(Test Access Port) Controller来完成的。在下一节，我们一起来看看TAP是如何工作的。 2. TAP(Test Access Port) 在上一节，我们已经简单介绍了边界扫描链，而且也了解了一般的芯片都会提供几条边界扫描链，用来实现完整的测试功能。下面，我将逐步介绍如何实现扫描链的控制和访问。 在IEEE 1149.1标准里面，寄存器被分为两大类：数据寄存器(DR－Data Register)和指令寄存器(IR－Instruction Register)。边界扫描链属于数据寄存器中很重要的一种。边界扫描链用来实现对芯片的输入输出的观察和控制。而指令寄存器用来实现对数据寄存器的控制，例如：在芯片提供的所有边界扫描链中，选择一条指定的边界扫描链作为当前的目标扫描链，并作为访问对象。下面，让我们从TAP(Test Access Port)开始。 2.1 接口信号定义 TAP是一个通用的端口，通过TAP可以访问芯片提供的所有数据寄存器（DR）和指令寄存器（IR）。对整个TAP的控制是通过TAP Controller来完成的。TAP总共包括5个信号接口TCK、TMS、TDI、TDO和TRST ：其中4个是输入信号接口和另外1个是输出信号接口。一般，我们见到的开发板上都有一个JTAG接口，该JTAG接口的主要信号接口就是这5个。下面，我先分别介绍这个5个接口信号及其作用。 Test Clock Input (TCK) TCK为TAP的操作提供了一个独立的、基本的时钟信号，TAP的所有操作都是通过这个时钟信号来驱动的。TCK在IEEE 1149.1标准里是强制要求的。 Test Mode Selection Input (TMS) TMS信号用来控制TAP状态机的转换。通过TMS信号，可以控制TAP在不同的状态间相互转换。TMS信号在TCK的上升沿有效。TMS在IEEE 1149.1标准里是强制要求的。 Test Data Input (TDI) TDI是数据输入的接口。所有要输入到特定寄存器的数据都是通过TDI接口一位一位串行输入的（由TCK驱动）。TDI在IEEE 1149.1标准里是强制要求的。 Test Data Output (TDO) TDO是数据输出的接口。所有要从特定的寄存器中输出的数据都是通过TDO接口一位一位串行输出的（由TCK驱动）。TDO在IEEE 1149.1标准里是强制要求的。 Test Reset Input (TRST) TRST可以用来对TAP Controller进行复位（初始化）。不过这个信号接口在IEEE 1149.1标准里是可选的，并不是强制要求的。因为通过TMS也可以对TAP Controller进行复位（初始化）。 2.2 指令寄存器、公共指令以及数据寄存器 在IEEE 1149.1标准当中，规定了一些指令寄存器、公共指令和相关的一些数据寄存器。对于特定的芯片而言，芯片厂商都一般都会在IEEE 1149.1标准的基础上，扩充一些私有的指令和数据寄存器，以帮助在开发过程中进行进行方便的测试和调试。在这一部分，我将简单介绍IEEE 1149.1规定的一些常用的指令及其相关的寄存器。 指令寄存器： 指令寄存器允许特定的指令被装载到指令寄存器当中，用来选择需要执行的测试，或者选择需要访问的测试数据寄存器。每个支持JTAG调试的芯片必须包含一个指令寄存器。 BYPASS指令和Bypass寄存器： Bypass寄存器是一个一位的移位寄存器，通过BYPASS指令，可以将bypass寄存器连接到TDI和TDO之间。在不需要进行任何测试的时候，将bypass寄存器连接在TDI和TDO之间，在TDI和TDO之间提供一条长度最短的串行路径。这样允许测试数据可以快速的通过当前的芯片送到开发板上别的芯片上去。 IDCODE指令和Device Identification 寄存器： Device identification寄存器中可以包括生产厂商的信息，部件号码，和器件的版本信息等。使用IDCODE指令，就可以通过TAP来确定器件的这些相关信息。例如，ARM MULTI-ICE可以自动识别当前调试的是什么片子，其实就是通过IDCODE指令访问Device Identification寄存器来获取的。 INTEST指令和Boundary-Scan 寄存器： Boundary-Scan寄存器就是我们前面例子中说到的边界扫描链，一般一个芯片内部有多个边界扫描链。通过边界扫描链，可以进行部件间的连通性测试。当然，更重要的是可以对测试器件的输入输出进行观测和控制，以达到测试器件的内部逻辑的目的。INTEST指令是在IEEE 1149.1标准里面定义的一条很重要的指令：结合边界扫描链，该指令允许对开发板上器件的系统逻辑进行内部测试。在ARM JTAG调试当中，这是一条频繁使用的测试指令。 我们前面说过，寄存器分为两大类：指令寄存器和数据寄存器。在上面提到的Bypass寄存器、Device Identification寄存器和Boundary-scan寄存器（边界扫描链），都属于数据寄存器。在调试当中，边界扫描寄存器（边界扫描链）最重要，使用的也最为频繁。 事实上，通过TAP接口，对数据寄存器（DR）进行访问的一般过程是： 通过指令寄存器（IR），选定一个需要访问的数据寄存器(bypass,ID,Boundary-scan)； 把选定的数据寄存器连接到TDI和TDO之间； 由TCK驱动，通过TDI，把需要的数据输入到选定的数据寄存器当中去；同时把选定的数据寄存器中的数据通过TDO读出来。 2.3 TAP状态机 接下来，让我们一起来了解一下TAP的状态机。TAP的状态机如图1所示，总共有16个状态。在TCK的驱动下，从当前状态到下一个状态的转换是由TMS信号决定。 这个状态机看似很复杂，其实理解以后会发现这个状态机其实很直接、很简单。观察上图，我们可以发现，除了Test-Logic Reset和Test-Run/Idle状态外，其他的状态有些类似。例如Select-DR-Scan和Select-IR-Scan对应，Capture-DR和Capture-IR对应，Shift-DR和Shift-IR对应，等等。在这些对应的状态中，DR表示Data Register，IR表示Instruction Register。记得我们前面说过吗，寄存器分为两大类，数据寄存器和指令寄存器。其实标识有DR的这些状态是用来访问数据寄存器的，而标识有IR的这些状态是用来访问指令寄存器的。 让我们来看一个更直观的例子。现在假设，TAP Controller 现在处在 Run-Test/Idle 状态，指令寄存器当中已经成功的写入了一条新的指令，该指令选定的是一条长度为6的边界扫描链。下面让我们来看看实际如何来访问这条边界扫描链。下图所示的是测试芯片及其被当前指令选定的长度为6的边界扫描链。由下图可以看出，当前选择的边界扫描链由6个边界扫描移位寄存器单元组成，并且被连接在TDI和TDO之间。TCK 时钟信号与每个边界扫描移位寄存器单元相连。每个时钟周期可以驱动边界扫描链的数据由TDI到TDO的方向移动一位，这样，新的数据可以通过 TDI 输入一位，边界扫描链的数据可以通过 TDO 输出一位。经过6个时钟周期，就可以完全更新边界扫描链里的数据，而且可以将边界扫描链里捕获的6位数据通过TDO全部移出来。 图(1)表示了芯片和边界扫描链的初始化状态，在测试状态下，芯片的外部输入和输出被隔离开了，芯片的输入和输出可以通过相应的边界扫描链来观察和控制。在图(1)中，扫描链里的每个移位寄存器单元的数据是不确定的，所以在图中用X表示，整个扫描链里的数据序列是XXXXXX。要从TDI输入到测试芯片上的数据序列是：101010. 同时要从TDO得到芯片相应管脚上的状态。现在TAP Controller从Run-Test/Idle状态经过Select-DR-Scan状态进入到Capture-DR状态，在 Capture-DR 状态当中，在一个TCK时钟的驱动下，芯片管脚上的信号状态全部被捕获到相应的边界扫描移位寄存器单元当中去，如图(2)所示。从图(2)中我们可以看出，在进入 Capture-DR 状态后，经过一个 TCK 时钟周期，现在扫描链中的数据序列变成了：111000. 在数据捕获完成以后，从Capture-DR状态进入到Shift-DR状态。在Shift-DR状态中，我们将通过6个TCK时钟周期来把新的数据序列（101010）通过 TDI 输入到边界扫描链当中去；同时，将边界扫描链中捕获的数据序列（111000）通过 TDO 输出来。在进入到 Shift-DR 状态后，每经过一个 TCK 时钟驱动，边界扫描链从 TDO 输出一位数据；同时，从 TDI 接收一位新的数据。图(3)所示的是在 Shift-DR状态下，1 个 TCK 时钟周期后的扫描链的变化。图(4)所示的是在Shift-DR状态下，2个TCK时钟周期后的扫描链的变化。此时，扫描链已经从TDI串行得到了两位新数据，从TDO也串行输出了两位数据。在TCK时钟的驱动下，这个过程一直继续下去。图(5)所示的是在经过6 个 TCK 时钟周期以后扫描链的情况。从图(5)中我们可以看到：边界扫描链当中已经包含了新的数据序列：101010. 在TDO端，经过6个TCK时钟驱动以后，也接收到了在Capture-DR状态下捕获到的数据序列：111000. 到目前为止，虽然扫描链当中包含了新的数据序列：101010，但测试芯片的管脚上的状态还是保持为：111000. 下一步，需要更新测试芯片相应管脚上的信号状态。要实现更新，TAP Controller 从 Shift-DR 状态，经过 Exit1-DR 状态，进入到 Update-DR 状态。在 Update-DR 状态中，经过一个周期的 TCK 时钟驱动，边界扫描链中的新数据序列将被加载到测试芯片的相应管脚上去，如图(6)所示。从图(6)可以看出，测试芯片的状态已经被更新，相应管脚上的状态序列已经从111000变为101010. 最后从 Update-DR状态回到 Run-Test/Idle 状态，完成对选定的边界扫描链的访问。 关于Pause-DR/Pause-IR状态 这两个状态是暂停状态，比如说我们要通过32bit的总线从一个48长度的扫描链中读出相应管脚的状态，我们需要读两次才能将48bit的扫描链状态读出来，先经过32个TCK时钟读出高32bit的状态，然后转到Pause-DR状态等待总线读响应，响应完成后再进入Shift-DR经过16个TCK时钟读出低16bit数据。","categories":[{"name":"ASIC测试","slug":"ASIC测试","permalink":"https://dxsm.github.io/categories/ASIC%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"jtag","slug":"jtag","permalink":"https://dxsm.github.io/tags/jtag/"}]},{"title":"AXI协议详解","slug":"axi_protocal","date":"2020-07-05T15:11:08.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/axi-protocal.html","link":"","permalink":"https://dxsm.github.io/p/axi-protocal.html","excerpt":"相较于AXI3，AXI4新增内容： support for burst lengths up to 256 beats Quality of Service (QoS) signaling support for multiple region interfaces updated write response requirements updated AWCACHE and ARCACHE signaling details additional information on Ordering requirements details of optional User signaling removal of locked transactions removal of write interleaving","text":"相较于AXI3，AXI4新增内容： support for burst lengths up to 256 beats Quality of Service (QoS) signaling support for multiple region interfaces updated write response requirements updated AWCACHE and ARCACHE signaling details additional information on Ordering requirements details of optional User signaling removal of locked transactions removal of write interleaving 信号 Source Desciption ACLK clock Source 全局时钟 ARESETn reset Source 全局复位 写地址通道 AWID master 写地址ID AWADDR master 写地址 AWLEN master burst长度(AXI3与AXI4不同) AWSIZE master burst中一次传输数据的大小 AWBURST master burst类型，FIXED(00), INCR(01), WRAP(10) AWLOCK master lock类型(AXI3与AXI4不同) AWCACHE master memory类型 AWPROT master 保护类型 AWQOS master Quality of Service(AXI4新增) AWREGION master 区域标识(AXI4新增) AWUSER master User signal(AXI4新增) AWVALID master 写地址有效 AWREADY slave slave准备好接受地址和控制信息标志 写数据通道 WID master 写ID tag, WID与AWID必须匹配(AXI4删除) WDATA master 写数据 WSTRB master 写阀门,WSTRB[n]标示的区间为WDATA[(8n)+7:(8n)] WLAST master burst中最后一笔传输标志 WUSER master User signal(AXI4新增) WVALID master 写数据有效 WREADY slave slave准备好接受数据标志 写响应通道 BID slave 写响应ID tag, BID必须与AWID匹配 BRESP slave 写响应 BUSER slave User signal(AXI4新增) BVALID slave 写响应有效 BREADY master master准备好接受写响应标志 读地址通道 ARID master 读地址ID ARADDR master 读地址 ARLEN master burst长度(AXI3与AXI4不同) ARSIZE master burst中一次传输数据的大小 ARBURST master burst类型 ARLOCK master lock类型(AXI3与AXI4不同) ARCACHE master memory类型 ARPROT master 保护类型 ARQOS master Quality of Service(AXI4新增) ARREGION master 区域标识(AXI4新增) ARUSER master User signal(AXI4新增) ARVALID master 读地址有效 ARREADY slave slave准备好接受地址和控制信息标志 读数据通道 RID slave 读ID tag,RID必须与ARID匹配 RDATA slave 读数据 RRESP slave 读响应 RLAST slave burst中最后一笔传输标志 RUSER slave User signal(AXI4新增) RVALID slave 读数据有效 RREADY master master准备好接受读数据标志","categories":[{"name":"SOC设计","slug":"SOC设计","permalink":"https://dxsm.github.io/categories/SOC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"AMBA","slug":"AMBA","permalink":"https://dxsm.github.io/tags/AMBA/"},{"name":"SOC","slug":"SOC","permalink":"https://dxsm.github.io/tags/SOC/"},{"name":"AXI","slug":"AXI","permalink":"https://dxsm.github.io/tags/AXI/"}]},{"title":"low power RTL优化","slug":"low power RTL优化","date":"2020-07-05T14:50:20.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/low-power-rtl-you-hua.html","link":"","permalink":"https://dxsm.github.io/p/low-power-rtl-you-hua.html","excerpt":"论坛里面讨论low power RTL前端设计的帖子好像不多，许多大牛的书上来就谈工艺，半导体结构，让我高山仰止，但也只能心向往之(实在有些看不懂)。 工艺的提升带来的收益可能远比RTL深度优化高，如TSMC 40LP vs TSMC 28HPC+, 后者基本上比前者面积小一半，速度快一倍，dynamic power小40 ~ 50%，代价是leakage高3~4倍。在老工艺上如何绞尽脑汁优化设计，可能也很难达到这种效果。 但作为前端RTL designer, 一旦工艺选定，我们只能在自己的一亩三分地里面做到最好，本帖就此抛砖迎玉，结合自己的工作经验讨论下low power RTLdesign, 挖个坑，希望坛子里的大牛一起帮忙填坑 刚入行做design时，考虑的是Area 和 speed，近些年来，power变成了越来越重要的指标，有时候更是牺牲Area和speed来换取power的收益，毕竟有些领域, 电池容量是很难增大的。 有人做过大体统计，降低功耗的方法和收益大体如下，对于前端RTL 设计，最好用的还是clock gating, 收益最显巨，代价最小， 其他方法也能有可观的收益，具体还的依靠具体应用场景分析。","text":"论坛里面讨论low power RTL前端设计的帖子好像不多，许多大牛的书上来就谈工艺，半导体结构，让我高山仰止，但也只能心向往之(实在有些看不懂)。 工艺的提升带来的收益可能远比RTL深度优化高，如TSMC 40LP vs TSMC 28HPC+, 后者基本上比前者面积小一半，速度快一倍，dynamic power小40 ~ 50%，代价是leakage高3~4倍。在老工艺上如何绞尽脑汁优化设计，可能也很难达到这种效果。 但作为前端RTL designer, 一旦工艺选定，我们只能在自己的一亩三分地里面做到最好，本帖就此抛砖迎玉，结合自己的工作经验讨论下low power RTLdesign, 挖个坑，希望坛子里的大牛一起帮忙填坑 刚入行做design时，考虑的是Area 和 speed，近些年来，power变成了越来越重要的指标，有时候更是牺牲Area和speed来换取power的收益，毕竟有些领域, 电池容量是很难增大的。 有人做过大体统计，降低功耗的方法和收益大体如下，对于前端RTL 设计，最好用的还是clock gating, 收益最显巨，代价最小， 其他方法也能有可观的收益，具体还的依靠具体应用场景分析。 Power 主要消耗在 combinational logic sequential logic memory clock network 下面我将就下面几个方面展开讨论, 1. Improve clock gating efficiency. Block level clock gating. RTL clock gating. (重点) 2. Reduce data toggle rate. fifovs PIPE FSM coding style Unnecessary reset. 3. Refine Memory Selection. Area power balance I/F bitwidth selection. Depth selection. 4. Reduce memory accessing Address caching. 5. Reduce logic size Logic sharing. Logic balancing Divider optimization. Reduce pipe line length Hardmacro vs Register Reduce bitwidth Async reset vs non-async-reset. 6. Misunderstanding （未完待续）","categories":[{"name":"低功耗设计","slug":"低功耗设计","permalink":"https://dxsm.github.io/categories/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"Low Power","slug":"Low-Power","permalink":"https://dxsm.github.io/tags/Low-Power/"}]},{"title":"芯片设计小实例之数据“瘦身”","slug":"芯片设计小实例--数据“瘦身”","date":"2020-06-22T16:07:48.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/xin-pian-she-ji-xiao-shi-li-shu-ju-shou-shen.html","link":"","permalink":"https://dxsm.github.io/p/xin-pian-she-ji-xiao-shi-li-shu-ju-shou-shen.html","excerpt":"我们知道在芯片设计中，降低动态功耗的方法有很多种。比如clock gating，power gating等。今天想介绍一个通过减小移动数据位宽来降低动态功耗的方法。 动态功耗的来源是信号的传播，翻转。clock gating通过减少时钟信号的翻转，降低了寄存器clk pin本身的功耗，并且通过寄存器的特性，间接减少了Q pin的翻转，从而降低了数据链路的功耗。而power gating更绝，直接将电路断电，更无翻转可言。这两种方式本质上都是在电路或者某些寄存器没有数据更新需求的时候减少无谓的信号翻转，以此来降低功耗。而减小传播数据的位宽，可以在有数据更新需求的时候减少动态功耗。毕竟传递的数据少了，需要翻转的信号自然也少了。但是这样做需要考虑上减小数据位宽所带来的一点额外逻辑开销造成的功耗。不过大多数时候都能得到正收益，特别是当数据位宽较大的时候。","text":"我们知道在芯片设计中，降低动态功耗的方法有很多种。比如clock gating，power gating等。今天想介绍一个通过减小移动数据位宽来降低动态功耗的方法。 动态功耗的来源是信号的传播，翻转。clock gating通过减少时钟信号的翻转，降低了寄存器clk pin本身的功耗，并且通过寄存器的特性，间接减少了Q pin的翻转，从而降低了数据链路的功耗。而power gating更绝，直接将电路断电，更无翻转可言。这两种方式本质上都是在电路或者某些寄存器没有数据更新需求的时候减少无谓的信号翻转，以此来降低功耗。而减小传播数据的位宽，可以在有数据更新需求的时候减少动态功耗。毕竟传递的数据少了，需要翻转的信号自然也少了。但是这样做需要考虑上减小数据位宽所带来的一点额外逻辑开销造成的功耗。不过大多数时候都能得到正收益，特别是当数据位宽较大的时候。 在之前的文章《芯片设计小实例——共享buffer》中，我们尝试用一个共享buffer实现了不同id数据流的仲裁调度。在这个微架构中，需要对多个entry的数据同时做移位，也就是一个移位寄存器，以此来满足我们搜索各id队列的队头的策略： 在上图中，每次调度读走一个数据，需要对该数据以上所有的数据做向下移位，（比如读走entry_1的数据，entry_2和entry_3的数据要向下移位），然后进行下一次的调度。这个方法其实是会产生较大动态功耗的，特别是当数据位宽很大，需要移位的数据很多的时候。 那么有没有办法避免这样的大数据位宽移动呢？答案是肯定的。为了找到这个办法，我们需要先了解数据移动的目的是什么。在这个例子中，之所以要对被读走数据以上的数据做集体向下移位，是为了保证从entry_0向上搜索的过程中所有id通道的数据是保序并且没有空洞的，因为我们默认了这个buffer从下往上的顺序对应着每个id 队列的从前往后的顺序（因为我们是自下而上有序地写入）。 如果不做这个移动，那么被读走的entry将形成一个数据空洞。当然在这个数据空洞被新的数据填充之前，这个保序规则都没有被打破，但很明显这样就大大降低了entry的利用率，因为在空洞以上所有数据都被读走之前，该空洞都无法被写入： 而如果有新的数据填入这个空洞，那么保序规则将被打破，除非被读走数据本身就处于buffer最顶部，如下图所示，id=0的第4个数据插在了第1个和第3个数据中间，对于id=0的队列，从下往上的数据序列变为1-&gt;4-&gt;3，保序规则被打破： 因此这里最好的办法就是对数据做向下移位，既可以充分利用每个entry，又可以维持队列顺序： 通过观察可以发现，这个移位在算法里是必要的，**但是这个移位与数据本身是什么，具体有多少bit并无直接的联系。我们移1024bit是这样移动，移512bit是这样移动，甚至移3个bit照样是一样的移动规则。**这就不禁让人思考，是否可以直接用3bit来代替1024bit的数据？或者说，给每个进入buffer的1024bit的数据起个别名？比如做一个名单： 在这个名单中，每个数据对应一个3bit的代号（假设这个buffer只有5个深度），这些代号各不相同，因此他们可以一一对应地指代不同的数据。然后之前的移动数据，就可以变成简单地移动这些代号： 如上图所示，维护一个新的“代号移动buffer”，在每次新写入一个数据的时候，将其代号写入这个“代号移动buffer”，就可以保持数据不变，将数据的移动转换为代号的移动，不管是多少bit的数据，都只移动3bit。而数据则可以原封不动地停留在buffer中（甚至数据也没必要从下往上按序写入，只要代号从下往上按序写入即可）。然后在每个代号被移动出buffer的时候，再将其转换为对应的数据读出，这样一来，移位寄存器的功耗就大大地降低了！ 这么做的代价有很多，比如需要维护一个“名单”，就要额外开辟一个3x5bit的名单列表，如果buffer深度较大，为了保证名单里的代号互不冲突，名单的位宽也要加大，这也会占用很多寄存器。这里可以再做一个优化，我们发现所谓的名单只要能保证在这个buffer里每个entry都不一样就可以了，而每个buffer本身就有这么个“名单”，无需另外维护，那就是buffer的index： 直接用index来作为每个数据的代号，在数据出buffer的时候还可以直接拿来索引真正的数据，一举两得。既省去了名单的寄存器，又减少了名单和数据转换的逻辑（只需要通过index选择读数据），真是太好了! 从这个小例子我们可以看到，合适巧妙地对数据进行“瘦身”，特别是类似移位寄存器这种需要大量进行移动的数据，可以有效地降低功耗，并且很多开销也不算大。使用这种方法的条件，是数据的移动规则与数据本身没有关系，并且数据有单独的固定空间存放，读写简单（最好是寄存器读写）。希望对大家有所帮助。","categories":[{"name":"ASIC设计","slug":"ASIC设计","permalink":"https://dxsm.github.io/categories/ASIC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计技巧","slug":"设计技巧","permalink":"https://dxsm.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/"},{"name":"资源优化","slug":"资源优化","permalink":"https://dxsm.github.io/tags/%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"}]},{"title":"芯片设计小经验之流保序策略","slug":"芯片设计小经验--流保序策略","date":"2020-06-21T15:02:12.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/xin-pian-she-ji-xiao-jing-yan-liu-bao-xu-ce-lue.html","link":"","permalink":"https://dxsm.github.io/p/xin-pian-she-ji-xiao-jing-yan-liu-bao-xu-ce-lue.html","excerpt":"今天想分享几种流保序策略。保序问题在不同的应用领域都会遇到，毕竟硬件电路本质上是需要很多数据流传输的。各种协议的接口，处理器的数据处理，指令处理等都离不开对应数据有序的传输。 如果只有一条数据流，可以直接使用一个FIFO保序。如果是多数据流，多个读写口，可以分不同ID使用不同FIFO保序。今天想讨论的是多数据流混合场景下只有1个读口和1个写口的保序。不同的数据流有对应不同的ID，大致有以下5种不同的保序策略。","text":"今天想分享几种流保序策略。保序问题在不同的应用领域都会遇到，毕竟硬件电路本质上是需要很多数据流传输的。各种协议的接口，处理器的数据处理，指令处理等都离不开对应数据有序的传输。 如果只有一条数据流，可以直接使用一个FIFO保序。如果是多数据流，多个读写口，可以分不同ID使用不同FIFO保序。今天想讨论的是多数据流混合场景下只有1个读口和1个写口的保序。不同的数据流有对应不同的ID，大致有以下5种不同的保序策略。 1. 不同ID使用不同FIFO分别保序 每个FIFO只需要储存数据就可以，各自维护一套读写指针，储存数据结构简单，只需要存下数据，无需其他信息。 优点：简单直观，时序好，易实现 缺点：静态配置，不够灵活，当ID多或者FIFO深度大的时候很占面积 2.不同ID使用同一共享”Buffer”，使用链表保序： 使用链表保序也是一种比较常见的做法。需要额外记录队头队尾的位置信息，以及下一个位置的指针信息，其数据结构如下： 基本读写规则和更新规则如下： 数据随意插空写入buffer 每次写入时将当前entry置为队尾，tail=1’b1 每次写入时搜索整个buffer中是否有同id的entry，若无同id，则head=1‘b1，若有，则搜索当前同id的队尾，将当前写入的位置信息更新到队尾所在entry的nxt_ptr 每个队列的head参与仲裁读出 每次读出时将相应队头的nxt_ptr所指的entry的head置为1’b1 优点：灵活配置，寄存器资源相对较少，并可被充分利用，特别适用于队列深度未知的场景。 缺点：更新复杂，时序较差，特别是每次读出一个队头更新下一个队头的时候，需要连续两次访问不同entry的buffer并做一个写操作，时序路径很长。 3.不同ID使用同一共享”Buffer”，使用队列计数器保序： 这种方法通过记录每个entry在当前buffer中处于所在队列的第几个位置来表征顺序。需要额外有一个计数器储存空间，其数据结构如下： 基本读写规则和更新规则如下： 数据随意插空写入buffer 每次写入时计算出当前buffer中同ID的entry个数，作为cnt记录 所有cnt=0的entry参与读出仲裁 每次读出一个数据，相同ID的所有entry的cnt均减1 优点：灵活配置，寄存器资源相对较少，并可被充分利用, 更新规则较为简单。 缺点：输入时序较差，需要做多bit加法。另外如果每个队列的深度未知，则此方案不可行，因为无法确定cnt的位宽。 4.不同ID使用同一共享”Buffer”，使用bitmap保序： 如上图所示，每个entry都保存了一个“bit map”，用来记录当前buffer所有位置的同id entry信息。其储存数据结构如下： 基本读写规则和更新规则如下： 数据随意插空写入buffer 每次写入时遍历buffer所有同id的entry，若有，则将该位置（可能有多个）对应的bit map置为1 Bit map为全0的位置可参与仲裁读出 每次读出更新所有同id的bit map，将相应位置置为0 优点：灵活配置，更新规则较为简单，时序相对较好。 缺点：若buffer深度较大，bit map面积太大。 5.不同ID使用同一共享”FIFO”，通过顺序写入+数据移位保序： 这种结构除了数据以外，每个entry需要额外存下vld，id和表示队列对头的head信息，数据结构如下： 优点：灵活配置，寄存器资源相对较少，并可被充分利用 缺点：因为要做数据移位，可能有较大功耗 以上便是几种不同的保序策略，希望对大家有所帮助。至于什么时候选择哪一种策略，则取决于实际场景和各种环节约束，需要因地制宜。","categories":[{"name":"ASIC设计","slug":"ASIC设计","permalink":"https://dxsm.github.io/categories/ASIC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计技巧","slug":"设计技巧","permalink":"https://dxsm.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/"},{"name":"流保序","slug":"流保序","permalink":"https://dxsm.github.io/tags/%E6%B5%81%E4%BF%9D%E5%BA%8F/"}]},{"title":"芯片设计小实例之共享Buffer","slug":"芯片设计小实例--共享Buffer","date":"2020-06-20T15:40:44.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/xin-pian-she-ji-xiao-shi-li-gong-xiang-buffer.html","link":"","permalink":"https://dxsm.github.io/p/xin-pian-she-ji-xiao-shi-li-gong-xiang-buffer.html","excerpt":"首先来看一下场景，这是一个在大多数设计中都会遇到的数据包调度问题。有A,B两个输入通道，向数据调度模块DUT输入数据。该调度模块DUT有一个输出通道C。A,B和DUT，DUT和C都是通过简单的握手传输数据。 两个输入通道都有数据包输入，可以同时输入。数据包以packet为单位，每个packet为128bit。不同的数据包有不同的id，id是4个bit。A和B通道不会同时输入同ID的数据。每个packet带有2bit的qos，qos越高，可以理解为该id的packet优先级相对于其他id的packet优先级越高。输出通道没有反压，只要有数据就可以出去。输入通道接受反压。数据输出的条件是，同id的packet要保序输出，不同id的packet，优先级较高的需要尽量先输出。","text":"首先来看一下场景，这是一个在大多数设计中都会遇到的数据包调度问题。有A,B两个输入通道，向数据调度模块DUT输入数据。该调度模块DUT有一个输出通道C。A,B和DUT，DUT和C都是通过简单的握手传输数据。 两个输入通道都有数据包输入，可以同时输入。数据包以packet为单位，每个packet为128bit。不同的数据包有不同的id，id是4个bit。A和B通道不会同时输入同ID的数据。每个packet带有2bit的qos，qos越高，可以理解为该id的packet优先级相对于其他id的packet优先级越高。输出通道没有反压，只要有数据就可以出去。输入通道接受反压。数据输出的条件是，同id的packet要保序输出，不同id的packet，优先级较高的需要尽量先输出。 从这个场景的几个条件，我们可以大概规划出这个DUT需要具备什么样的功能。首先，从两个通道输入和一个通道输出，输入通道可以同时有效这点可以看出来这是一个输入输出流量不匹配的模块，必须要有缓存。因为没有具体的输入场景描述，单纯从输入输出口数量来进行判断，这个缓存的buffer深度可以设成任意无限大，因为极限场景就是每拍a和b都同时有1个packet输入，因为c只能有1个packet输出，每拍都会有1个packet残留。但因为有反压机制，当残留packet到达缓存上限的时候就可以反压端口，因此一个合适的buffer深度足矣。 除了缓存数据，这个DUT还有一个重要的功能就是调度不同id的packet，使其尽量按照qos从大到小的顺序输出。这个输出特点决定了缓存深度不能设置的太小。设置的太小，可同时进行比较的packet数量太少，qos按顺序输出的范围太小。只有将更多的packet储存下来进行qos比较，才能在一个合理的时间范围内保证降序输出qos。为了简单起见，这里buffer深度设置为12（该深度与A,B输入的实际流量，或者说链路利用率强相关，这里不多加讨论）。 有了足够深度的buffer来缓存packet，我们需要将packet按id进行分类，因为同id的packet需要保序输出，然后对不同id的packet进行调度。这里涉及到两个关键点，保序和调度。因为输入的同id的packet本身是保序的，因此为了让输出保序，很容易就想到了经典的First In First Out这样的FIFO结构。又因为不同id的packet之间要进行调度，很容易就想到每个id的packet设置一个独立的FIFO，然后在每个FIFO出口处进行调度。至于调度，有几种不同的算法，本文也不多加讨论，简而言之就是选出最高qos的可调度packet，然后通过round-robin或者sp等调度算法进行调度。 这样一来，一个粗略的方案便形成了。通过对每个id设立不同的FIFO来进行缓存packet，在每个id的FIFO出口进行仲裁调度，输出高qos的packet。因为输入的id是3个bit，所以最多有7种不同的id，需要设置7个FIFO，简单的微架构图如下： 这个方案从功能角度来说是可以满足要求的。但是就是有点占资源。因为在这个方案中对每个id都设置了对应的FIFO来解决保序+调度的需求，所以FIFO数量等于id的所有可能数量。如果id的位宽小，packet的数据位宽小，那还可以接受，但如果id有12bit呢？packet的数据位宽有1024bit呢？那么岂不是需要4K个1024bit的FIFO，深度还需要设置呢，这么一想便觉得此方案有其局限性。要知道寄存器怎么来说都是理论上的面积大户，一般能少则少。 在上图架构中我们之所以将不同的ID设置一个单独的FIFO初衷只是因为这种方式最直观地将所有的id区分开，相信大多数人对于此场景的第一反应都是类似的架构。通过输入的ID“静态”地将数据打入对应ID的FIFO，“静态”地隔离开了不同ID的packet，便于后续的仲裁调度。但是再仔细一想，我们为此将所有可能的ID全部设置了单独的FIFO，但并不是每个ID在某一个特定时间段内都会出现，也就是说在进行仲裁调度的时候，很可能某些FIFO是没有东西的。但是因为这些FIFO只能被相应ID的packet占用，别的ID的packet就算自己的FIFO被占用满了，也没法使用，那么这些个FIFO岂不是浪费了？如果这些FIFO可以被别的ID使用，是不是更好？ 这里便可以引入我们标题里的“共享buffer”概念。这里的共享指的是不同ID packet之间的共享。我们试图使用一个“共享buffer”来缓存在某一个大流量时刻所有ID的packet，并从中选择每个ID的队头packet进行仲裁调度。这个buffer为了与分ID设置的FIFO达到相同的功能，势必需要储存除了packet data以外更多的信息。这里主要有几点。 为了区分不同ID的packet，需要将每个packet的对应ID也存到buffer的相应entry。 同ID的packet之间可能间插了别的ID的packet，因此该共享buffer的读指针不能按一般的FIFO来设置。事实上，因为我们只需要对每个ID对应队列的队头packet进行仲裁调度，我们只需要知道每个ID的队头是哪个位置便可，每个ID队列里其他的packet处于哪个位置我们并不在乎。因此，需要1个bit来标识为对应ID的队头。 因为该共享buffer的读写不同于普通FIFO，为了便于迅速找出所有有效的entry，设置一个vld bit来表征。 因此这个共享buffer的储存数据结构大致如下： Head bit的更新主要是以下两个条件： 当新的packet写入时，需要遍历当前共享buffer所有的有效entry，若没有与自己id匹配的entry，将head设置为1‘b1。 当有packet被仲裁调度调度走之后，需要做一个数据移位，将晚于被调度走的buffer entry的所有entry向下移位，保证所有有效的buffer是连续的，然后从0位置开始自下往上寻找第一个与被调走的packet同id的entry，将其设置为新的head。 这样一来，在调度的时候，只需要找到所有head bit为1‘b1的有效entry，便和每个ID都设置独立FIFO，对所有FIFO队头进行调度有一样的效果了。当然，在该共享buffer的写端口，需要保证和正常FIFO一样按序写入。只不过这里因为搜索队头的策略，该buffer不支持“套圈”读写，写指针写到buffer顶部时便无法再写入。至于该共享buffer的深度，设置成与单个ID FIFO一样的深度便可保证大部分情况下与分ID FIFO有相同效果（当然这取决于实际流量，可能需要适当增加一些）。 该共享buffer的微架构大致如下： 以上便用一个组合逻辑多一些的架构替代了一个寄存器非常多的架构。这个微架构的优势在于灵活，在大数据宽度，多id的情况下可以尽可能地节省面积。这里用到的思想其实就是“分时复用“。同一个buffer entry在不同的时候可以被不同ID的packet所占用。当然实现起来更为复杂，毕竟引入了一些新的状态位需要维护和更新。还有一些具体的时序问题，以及设计细节没有在本文中一一尽述。但是这样的缩减面积的思想其实是可以被参考借鉴的，希望可以对大家有所帮助。","categories":[{"name":"ASIC设计","slug":"ASIC设计","permalink":"https://dxsm.github.io/categories/ASIC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"设计技巧","slug":"设计技巧","permalink":"https://dxsm.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/"},{"name":"资源优化","slug":"资源优化","permalink":"https://dxsm.github.io/tags/%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"}]},{"title":"Python正则表达式","slug":"python_regular_expression","date":"2019-08-24T08:30:02.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/python-regular-expression.html","link":"","permalink":"https://dxsm.github.io/p/python-regular-expression.html","excerpt":"1. 为什么使用正则表达式？ 典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 通过使用正则表达式，可以： 测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。","text":"1. 为什么使用正则表达式？ 典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 通过使用正则表达式，可以： 测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。 2. 匹配规则 3. re模块常用函数 3.1 re.match函数 re.match尝试从字符串的起始位置匹配一个模式，匹配成功则返回match对象；如果不是起始位置匹配成功的话，match()就返回none。 函数语法： re.match(pattern, string[, flags=0]) 函数参数说明： pattern：匹配的正则表达式 string：要匹配的字符串。 flags：标志位，用于控制正则表达式的匹配方式，取值可以使用按位或运算符’|'表示同时生效 re.I(re.IGNORECASE)：忽略大小写 re.M(re.MULTILINE)：多行匹配，改变’^‘和’$'的行为 re.S(re.DOTALL)：改变’.‘的行为，使’.'匹配包括换行在内的所有字符 re.L(re.LOCALE)：做本地化识别（locale-aware）匹配，使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 re.U(re.UNICODE)：根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X(re.VERBOSE)： 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 3.1.1 返回值match对象 Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。 属性： string: 匹配时使用的文本。 re: 匹配时使用的Pattern对象。 pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.search()方法的同名参数相同。 endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.search()方法的同名参数相同。 lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。 lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。 方法： group([group1, …]): 获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 span([group]): 返回(start(group), end(group))。 expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，而不是分组10，只能使用\\g&lt;1&gt;0。 3.1.2 实例 #!/usr/bin/env python import re str1 = \"\"\"baidu.com www.google.com www.12306.cn\"\"\" str2 = \"\"\"www.baidu.com www.google.com www.12306.cn\"\"\" pattern = r\"(\\w+)\\.(\\w+)\\.(?P&lt;domain>\\w+)\" match = re.match(pattern, str1) print(match) #None match = re.match(pattern, str2) print(match) #&lt;_sre.SRE_Match object; span=(0, 13), match='www.baidu.com'> if match: print(match.pos) #0 print(match.endpos) #41 print(match.group()) #www.baidu.com print(match.group(2)) #baidu print(match.group(2,3)) #('baidu', 'com') print(match.groups()) #('www', 'baidu', 'com') print(match.groupdict()) #{'domain': 'com'} print(match.span()) #(0, 13) print(match.span(3)) #(10, 13) print(match.start(3)) #10 print(match.expand(r\"\\3 \\1 \\2 \\g&lt;domain>\")) #com www baidu com else: print(\"No match!!!\") 3.2 re.search函数 re.search扫描整个字符串并返回第一个成功的匹配。 函数语法： re.search(pattern, string[, flags=0]) 实例 #!/usr/bin/env python import re str1 = \"\"\"baidu.com www.google.com www.12306.cn\"\"\" str2 = \"\"\"www.baidu.com www.google.com www.12306.cn\"\"\" pattern = r\"(\\w+)\\.(\\w+)\\.(?P&lt;domain>\\w+)\" match = re.search(pattern, str1) print(match) #&lt;_sre.SRE_Match object; span=(10, 24), match='www.google.com'> match = re.search(pattern, str2) print(match) #&lt;_sre.SRE_Match object; span=(0, 13), match='www.baidu.com'> 3.3 re.findall函数 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 函数语法： re.findall(pattern, string[, flags=0]) 实例 #!/usr/bin/env python import re text = \"\"\"www.baidu.com Site: www.google.com www.12306.cn\"\"\" pattern = r\"(\\w+)\\.(\\w+)\\.(\\w+)\" match = re.findall(pattern, text, re.M) print(match) #[('www', 'baidu', 'com'), ('www', 'google', 'com'), ('www', '12306', 'cn')] 3.4 re.finditer函数 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器 函数语法： re.finditer(pattern, string[, flags=0]) 实例 #!/usr/bin/env python import re for m in re.finditer(r\"\\d+\",'one1two2three3four4'): print(m.group(), end=\" \") #1 2 3 4 3.5 re.sub函数 使用repl替换string中每一个匹配的子串后返回替换后的字符串。 当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。 当repl是一个函数时，这个函数应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 count用于指定最多替换次数，不指定时全部替换。 函数语法： re.sub(pattern, repl, string[, count]) 实例 #!/usr/bin/env python import re text = 'i say, hello world!' pattern = r'(\\w+) (\\w+)' print(re.sub(pattern, r'\\2 \\1', text)) #say i, world hello! def func(m): return m.group(1).title() + ' ' + m.group(2).title() print(re.sub(pattern, func, text)) #I Say, Hello World! print(re.sub(pattern, func, text, 1)) #I Say, hello world! 3.6 re.subn函数 返回 (sub(repl, string[, count]), 替换次数)。 函数语法： re.subn(pattern, repl, string[, count]) 实例 #!/usr/bin/env python import re text = 'i say, hello world!' pattern = r'(\\w+) (\\w+)' print(re.sub(pattern, r'\\2 \\1', text)) #('say i, world hello!', 2) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print(re.sub(pattern, func, text)) #('I Say, Hello World!', 2) print(re.sub(pattern, func, text, 1)) #('I Say, hello world!', 1) 3.7 re.split函数 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 函数语法： re.split(pattern, string[, maxsplit]): 实例 #!/usr/bin/env python import re text = 'one1two2three3four4' pattern = r\"\\d+\" print(re.split(pattern, text)) #['one', 'two', 'three', 'four', ''] print(re.split(pattern, text, 2)) #['one', 'two', 'three3four4'] 4. Pattern对象 re.compile函数构造： re.compile(strPattern[, flag]) 方法： match(string[, pos[, endpos]])：功能等同于re.match函数。不同的是可以指定匹配的起始与终止下标，pos和endpos的默认值分别为0和len(string)，re.match()无法指定这两个参数。 search(string[, pos[, endpos]])：同上 findall(string[, pos[, endpos]])：同上 finditer(string[, pos[, endpos]])：同上 sub(repl, string[, count]) subn(repl, string[, count]) split(string[, maxsplit]) 实例 #!/usr/bin/env python import re s = \"Steven is 17 years old.\" p = re.compile(r\"\\d+\") print(p.match(s)) #None print(p.match(s,10)) #&lt;_sre.SRE_Match object; span=(10, 12), match='17'> 5. 匹配方式–flags 5.1 re.M 实例：替换多行的行首note为warning #!/usr/bin/env python import re text = \"\"\"note: Meeting will begin at 8:00. note: Please take your notebook. note: Meeting will end at 10:00. (note: turn off the light) \"\"\" p = re.compile(r\"^note\") print((p.sub(\"warning\",text))) #only the first line has substitute p = re.compile(r\"^note\", re.M) print((p.sub(\"warning\",text))) #sub all line 5.2 re.S 改变’.'符号的行为，使其能够匹配换行符 #!/usr/bin/env python import re text = \"\"\" parameter MODE = 1 , DIN_WIDTH = 32, DOUT_WIDTH = 24; \"\"\" p = re.compile(r\"parameter(.*);\") m = p.search(text) print(m) #None p = re.compile(r\"parameter\\s+(.*);\", re.S) m = p.search(text) print(m.group(1)) 6. 贪婪模式 Python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式&quot;ab*“如果用于查找&quot;abbbc”，将找到&quot;abbb&quot;。而如果使用非贪婪的数量词&quot;ab*?&quot;，将找到&quot;a&quot;。 #!/usr/bin/env python import re text = \"abcaxc\" m = re.match(r\"ab.*c\",text) print(m.group()) #abcaxc m = re.match(r\"ab.*?c\",text) print(m.group()) #abc","categories":[{"name":"Python","slug":"Python","permalink":"https://dxsm.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dxsm.github.io/tags/Python/"},{"name":"正则","slug":"正则","permalink":"https://dxsm.github.io/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"异步FIFO设计","slug":"fifo_design","date":"2019-05-04T15:30:02.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/fifo-design.html","link":"","permalink":"https://dxsm.github.io/p/fifo-design.html","excerpt":"","text":"1. 异步fifo代码 module afifo #(parameter DATA_WIDTH = 64, FIFO_DEPTH = 8, AF_LEVEL = (1&lt;&lt;FIFO_DEPTH - 10), AE_LEVEL = 10 ) ( input wclk , input wrst , input wen , input [DATA_WIDTH-1:0] wdata , output reg wfull , output reg walmost_full , input rclk , input rrst , input ren , output reg [DATA_WIDTH-1:0] rdata , output reg rempty , output reg ralmost_empty ); wire fifo_rd; wire fifo_wr; wire [FIFO_DEPTH-1:0] raddr; wire [FIFO_DEPTH-1:0] waddr; reg [DATA_WIDTH-1:0] memory [0:(1&lt;&lt;FIFO_DEPTH)-1]; wire wen_mask; wire [FIFO_DEPTH:0] wbinnext; wire [FIFO_DEPTH:0] wptrnext; reg [FIFO_DEPTH:0] wbin; reg [FIFO_DEPTH:0] wptr; reg [FIFO_DEPTH:0] wptr_rsync1; reg [FIFO_DEPTH:0] wptr_rsync2; wire [FIFO_DEPTH:0] wbin_rsync; wire ren_mask; wire [FIFO_DEPTH:0] rbinnext; wire [FIFO_DEPTH:0] rptrnext; reg [FIFO_DEPTH:0] rbin; reg [FIFO_DEPTH:0] rptr; reg [FIFO_DEPTH:0] rptr_wsync1; reg [FIFO_DEPTH:0] rptr_wsync2; wire [FIFO_DEPTH:0] rbin_wsync; genvar i; //************************************* // Dual port RAM //************************************* assign fifo_wr = wen_mask; always @(posedge wclk) begin if(fifo_wr) memory[waddr] &lt;= wdata; end assign fifo_rd = ren_mask; always @(posedge rclk) begin if(fifo_rd) rdata &lt;= memory[raddr]; end // //************************************* // sync wptr to rclk domain //************************************* always @(posedge rclk or negedge rrst) begin if(rrst) {wptr_rsync2,wptr_rsync1} &lt;= 0; else {wptr_rsync2,wptr_rsync1} &lt;= {wptr_rsync1,wptr}; end generate for(i=FIFO_DEPTH;i>=0;i=i-1) begin: wbin_rsync_gen assign wbin_rsync[i] = ^({ {i{1'b0}},wptr_rsync2[FIFO_DEPTH:i]}); end endgenerate //************************************* // sync rptr to wclk domain //************************************* always @(posedge wclk or negedge wrst) begin if(wrst) {rptr_wsync2,rptr_wsync1} &lt;= 0; else {rptr_wsync2,rptr_wsync1} &lt;= {rptr_wsync1,rptr}; end generate for(i=FIFO_DEPTH;i>=0;i=i-1) begin: rbin_wsync_gen assign rbin_wsync[i] = ^({ {i{1'b0}},rptr_wsync2[FIFO_DEPTH:i]}); end endgenerate //************************************* // rd addr generate //************************************* always @(posedge rclk or negedge rrst) begin if(rrst) {rbin,rptr} &lt;= 0; else {rbin,rptr} &lt;= {rbinnext,rptrnext}; end assign raddr = rbin[FIFO_DEPTH-1:0]; assign ren_mask = ren &amp; (~rempty); assign rbinnext = ren_mask ? (rbin + 1'b1) : rbin; assign rptrnext = (rbinnext>>1) ^ rbinnext; //************************************* // wr addr generate //************************************* always @(posedge wclk or negedge wrst) begin if(wrst) {wbin,wptr} &lt;= 0; else {wbin,wptr} &lt;= {wbinnext,wptrnext}; end assign waddr = wbin[FIFO_DEPTH-1:0]; assign wen_mask = (wen &amp; (~wfull)); assign wbinnext = wen_mask ? (wbin + 1'b1) : wbin; assign wptrnext = (wbinnext>>1) ^ wbinnext; //************************************* // FIFO status //************************************* always @(posedge rclk or negedge rrst) begin if(rrst) rempty &lt;= 1'b1; else rempty &lt;= (rptrnext == wptr_rsync2); end always @(posedge rclk or negedge rrst) begin if(rrst) ralmost_empty &lt;= 1'b1; else ralmost_empty &lt;= (wbin_rsync - rbinnext &lt;= AE_LEVEL); end always @(posedge wclk or negedge wrst) begin if(wrst) wfull &lt;= 0; else wfull &lt;= (wptrnext == {~rptr_wsync2[FIFO_DEPTH:FIFO_DEPTH-1],rptr_wsync2[FIFO_DEPTH-2:0]}); end always @(posedge wclk or negedge wrst) begin if(wrst) walmost_full &lt;= 1'b1; else walmost_full &lt;= (wbinnext - rbin_wsync >= AF_LEVEL); end endmodule","categories":[{"name":"ASIC设计","slug":"ASIC设计","permalink":"https://dxsm.github.io/categories/ASIC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"fifo","slug":"fifo","permalink":"https://dxsm.github.io/tags/fifo/"}]},{"title":"搭建irun编译与起verdi小环境","slug":"compile_env","date":"2019-05-04T14:30:02.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/compile-env.html","link":"","permalink":"https://dxsm.github.io/p/compile-env.html","excerpt":"1. 小环境makefile模板 design = tb verilog_flist = -f ./test.vc tb.v vhd_flist = wave = wave.fsdb #whether to open verdi wave gui ifdef wave verdi_cmd += -ssf $(wave) endif .PHONY: help clean ius compile verdi help: @echo \"#===============================================================\" @echo \"# [Info] make help : show help infomation\" @echo \"# [Info] make clean : clean ius and verdi compile library,log\" @echo \"# [Info] make compile : compile for verdi\" @echo \"# [Info] make verdi : raise verdi gui\" @echo \"#===============================================================\" clean: @rm chip_lib.lib++ work.lib++ INCA_libs verdiLog vericomLog vhdlcomLog -rf ius: irun +access+wr -smartorder -clean -ntcnotchks -V93 -vtimescale 1ns/1ps +define+RD=1 -work chip_lib $(verilog_flist) $(vhd_flist) -top $(design) -64bit compile: ifdef vhdl_flist vhdlcom -V93 -sup_sem_error -smartorder -work chip_lib $(vhdl_flist) endif ifdef verilog_flist vericom -sv +systemverilog+sv +v95ext+v95 +verilog2001ext+v -ignorekwd_config +define+RD=1 -work chip_lib $(verilog_flist) endif verdi:compile verdi -lib chip_lib $(verdi_cmd) &amp;","text":"1. 小环境makefile模板 design = tb verilog_flist = -f ./test.vc tb.v vhd_flist = wave = wave.fsdb #whether to open verdi wave gui ifdef wave verdi_cmd += -ssf $(wave) endif .PHONY: help clean ius compile verdi help: @echo \"#===============================================================\" @echo \"# [Info] make help : show help infomation\" @echo \"# [Info] make clean : clean ius and verdi compile library,log\" @echo \"# [Info] make compile : compile for verdi\" @echo \"# [Info] make verdi : raise verdi gui\" @echo \"#===============================================================\" clean: @rm chip_lib.lib++ work.lib++ INCA_libs verdiLog vericomLog vhdlcomLog -rf ius: irun +access+wr -smartorder -clean -ntcnotchks -V93 -vtimescale 1ns/1ps +define+RD=1 -work chip_lib $(verilog_flist) $(vhd_flist) -top $(design) -64bit compile: ifdef vhdl_flist vhdlcom -V93 -sup_sem_error -smartorder -work chip_lib $(vhdl_flist) endif ifdef verilog_flist vericom -sv +systemverilog+sv +v95ext+v95 +verilog2001ext+v -ignorekwd_config +define+RD=1 -work chip_lib $(verilog_flist) endif verdi:compile verdi -lib chip_lib $(verdi_cmd) &amp;","categories":[{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/categories/eda-tools/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/tags/eda-tools/"}]},{"title":"git配置与使用教程","slug":"git_learning","date":"2019-05-04T14:23:02.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/git-learning.html","link":"","permalink":"https://dxsm.github.io/p/git-learning.html","excerpt":"1. git配置 放在~/.gitconfig文件中 [user] name = victor.dong email = dxs_uestc@163.com [color] ui = auto [alias] st = status co = checkout ci = commit br = branch df = diff dfn = diff --name-only dfs = diff --staged dft = difftool dfts = difftool --staged mr = merge mrt = mergetool last = log -1 HEAD amend = commit -C HEAD -a --amend lg = log --color --graph --pretty=format:'%C(yellow)%h%C(reset) - %C()%cd%C(reset) %C()&lt;%an>%C(reset)%C(red)%d%C(reset) %C(ul)%s%C(reset)' --abbrev-commit --date=format:'%y/%m/%d %H:%M:%S' ls = log --name-only --color --graph --pretty=format:'%C(yellow)%h%C(reset) - %C()%cd%C(reset) %C()&lt;%an>%C(reset)%C(red)%d%C(reset) %C(ul)%s%C(reset)' --abbrev-commit --date=format:'%y/%m/%d %H:%M:%S' #not show log in new page [core] pager = #diff tool use beyond compare [diff] tool = bcomp [difftool \"bcomp\"] cmd = \\\"/usr/bin/bcompare\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" [difftool] prompt = false #merge tool use beyond compare [merge] tool = bcomp [mergetool \"bcomp\"] cmd = \\\"/usr/bin/bcompare\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" \\\"$MERGED\\\" [mergetool] prompt = false","text":"1. git配置 放在~/.gitconfig文件中 [user] name = victor.dong email = dxs_uestc@163.com [color] ui = auto [alias] st = status co = checkout ci = commit br = branch df = diff dfn = diff --name-only dfs = diff --staged dft = difftool dfts = difftool --staged mr = merge mrt = mergetool last = log -1 HEAD amend = commit -C HEAD -a --amend lg = log --color --graph --pretty=format:'%C(yellow)%h%C(reset) - %C()%cd%C(reset) %C()&lt;%an>%C(reset)%C(red)%d%C(reset) %C(ul)%s%C(reset)' --abbrev-commit --date=format:'%y/%m/%d %H:%M:%S' ls = log --name-only --color --graph --pretty=format:'%C(yellow)%h%C(reset) - %C()%cd%C(reset) %C()&lt;%an>%C(reset)%C(red)%d%C(reset) %C(ul)%s%C(reset)' --abbrev-commit --date=format:'%y/%m/%d %H:%M:%S' #not show log in new page [core] pager = #diff tool use beyond compare [diff] tool = bcomp [difftool \"bcomp\"] cmd = \\\"/usr/bin/bcompare\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" [difftool] prompt = false #merge tool use beyond compare [merge] tool = bcomp [mergetool \"bcomp\"] cmd = \\\"/usr/bin/bcompare\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" \\\"$MERGED\\\" [mergetool] prompt = false","categories":[{"name":"git","slug":"git","permalink":"https://dxsm.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://dxsm.github.io/tags/git/"}]},{"title":"vim配置方案","slug":"vim_cfg","date":"2019-05-04T07:23:02.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/vim-cfg.html","link":"","permalink":"https://dxsm.github.io/p/vim-cfg.html","excerpt":"1. VIM插件及效果图 插件推荐： NERDTree: 树型目录 supertab: 自动补全，支持补全路径 UltiSnips: 补全代码神器 vim-snippets: 将UltiSnips文件夹拷贝到~/.vim 效果图：","text":"1. VIM插件及效果图 插件推荐： NERDTree: 树型目录 supertab: 自动补全，支持补全路径 UltiSnips: 补全代码神器 vim-snippets: 将UltiSnips文件夹拷贝到~/.vim 效果图： 2. VIM配置方案 将如下配置放在~/.vimrc文件下 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => General \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Sets how many lines of history VIM has to remember set history=500 \" display numbers set nu \"visual edit everywhere set virtualedit=all \"show command set showcmd set cmdheight=2 set scrolloff=3 \" Enable filetype plugins filetype plugin on filetype indent on \" Set to auto read when a file is changed from the outside set autoread set nocompatible \" Search set ignorecase \" Ignore case when searching set smartcase \" When searching try to be smart about cases set hlsearch \" Highlight search results set incsearch \" Makes search act like search in modern browsers \" Don't redraw while executing macros (good performance config) set lazyredraw \" For regular expressions turn magic on set magic \" Show matching brackets when text indicator is over them set showmatch \" How many tenths of a second to blink when matching brackets set mat=2 \" No annoying sound on errors set noerrorbells set novisualbell set t_vb= set tm=500 \" Add a bit extra margin to the left set foldcolumn=1 set fdm=marker \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => Colors and Fonts \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Enable syntax highlighting syntax enable colorscheme monokai \"colorscheme murphy \"colorscheme solarized \"let g:solarized_termcolors=256 \"let g:solarized_contrast=\"high\" \"default value is normal set t_Co=256 \"set vim terminal color set background=dark \"set guifont=Mono\\ 13 set guifont=monaco\\ 14 \" Set extra options when running in GUI mode if has(\"gui_running\") set guioptions+=m \"hide menu set guioptions-=T \"hide tool set guioptions-=L \"hide left scrollbar set guioptions-=r \"hide right scrollbar set guioptions-=b \"hide bottom scrollbar set guitablabel=%M\\ %t else \"hi Comment term=italic ctermfg=Darkgray \" colorscheme molokai endif \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => Statusline setting \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" set statusline=%1*\\ [%{Disp_Mode()}]\\ %*\\ %-5.58(%F%m%r%h%w%)\\ %2*\\ %-5.58(CWD:\\ %{getcwd()}%)\\ %*\\ Format:\\ [%{&amp;fenc!=''?&amp;fenc:&amp;enc}]\\ %3*\\ FileType:\\ %y\\ %*\\ %([L:\\ %l,C:\\ %c][%p%%]%)%&lt; hi User1 guibg=slateblue guifg=Gray ctermfg=Gray ctermbg=93 hi User2 guibg=#4876FF guifg=Gray ctermfg=Gray ctermbg=53 hi User3 guibg=Brown guifg=Gray ctermfg=Gray ctermbg=160 hi StatusLine guibg=#cccccc guifg=#222222 set laststatus=2 \"2:always display \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => file coding and decoding \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Set utf8 as standard encoding and en_US as the standard language set termencoding=utf-8 set encoding=utf8 set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,latin1 \"decoding list set fileencoding=utf-8 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => Files, backups and undo \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Turn backup off, since most stuff is in SVN, git et.c anyway... set nobackup set nowb set noswapfile \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => Text, tab and indent related \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" 1 tab == 4 spaces set shiftwidth=4 set tabstop=4 set softtabstop=4 \" Use spaces instead of tabs set expandtab \" Be smart when using tabs set smarttab \"toggle paste mode with hitting F2 key set pastetoggle=&lt;F2> \"set paste \"open paste mode set ai \"Auto indent set si \"Smart indent \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Wrap and breakline setting \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Linebreak on 500 characters set lbr \"linebreak set tw=500 \"break at 500 words set showbreak==>\\ \"show \"=>\" before the break line set wrap \"Wrap lines \"configure backspace set backspace=eol,start,indent set whichwrap+=&lt;,>,h,l \" Highlight the current line set cursorline \"highlight CursorLine guibg=#003853 ctermbg=24 gui=none cterm=none set clipboard=unnamed \"yank unnamed register to the system register \" Return to last edit position when opening files (You want this!) autocmd! BufReadPost * \\ if line(\"'\\\"\") > 0 &amp;&amp; line(\"'\\\"\") &lt;= line(\"$\") | \\ exe \"normal! g`\\\"\" | \\ endif \"auto load ~/.vimrc autocmd! BufWritePost $MYVIMRC source $MYVIMRC let mapleader = ',' let g:mapleader = ',' \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"save and quit \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"quit without save map &lt;leader>q :q!&lt;cr> \"save and quit map &lt;leader>w :wq!&lt;cr> \"save force with :W \"command! W w !sudo tee % > /dev/null \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"save and quit \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" map &lt;leader>tn :tabnew&lt;cr> map &lt;leader>tc :tabclose&lt;cr> map &lt;C-tab> :tabn&lt;cr> map &lt;C-S-tab> :tabp&lt;cr> \" no highlight map &lt;leader>/ :nohl&lt;cr> \" Merge selected text into one line vmap &lt;leader>m J \" change all the tab into space nmap &lt;leader>rt :retab!&lt;cr> \" update when diff two files nmap &lt;leader>du :diffupdate&lt;cr> \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"copy and paste \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"map &lt;C-A> ggVG \"map! &lt;C-A> &lt;Esc>ggVG \" copy \"vmap &lt;C-c> \"+y \" cut \"vmap &lt;C-x> \"+x \" paste nmap &lt;leader>p \"+gP \"back to file nmap &lt;leader>b :bf&lt;CR> nmap gt &lt;C-w>gf vnoremap gt &lt;C-w>gf \" tab to indent and shift-tab to unindent nmap &lt;tab> >> vmap &lt;tab> >gv nmap &lt;S-tab> &lt;&lt; vmap &lt;S-tab> &lt;gv imap &lt;S-tab> &lt;ESC>&lt;&lt;i \"visual block key i behaves like &lt;shift-i> vnoremap &lt;expr> i mode()=~'\\cv' ? 'i' : 'I' vnoremap &lt;expr> a mode()=~'\\cv' ? 'a' : 'A' \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"auto complete (),[],{}and so on \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" :inoremap ( ()&lt;Left> :inoremap ) &lt;c-r>=ClosePair(')')&lt;CR> :inoremap { {}&lt;Left> autocmd FileType c,cpp :inoremap { {&lt;CR>}&lt;ESC>O :inoremap } &lt;c-r>=ClosePair('}')&lt;CR> :inoremap [ []&lt;Left> :inoremap ] &lt;c-r>=ClosePair(']')&lt;CR> :inoremap \" \"\"&lt;Left> \"autocmd Filetype c,cpp,python,perl :inoremap ' ''&lt;ESC>i function! ClosePair(char) if getline('.')[col('.') - 1] == a:char return \"\\&lt;Right>\" else return a:char endif endfunction \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"自动插入文件头 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" autocmd! BufNewFile * silent! 0r ~/.vim/skel/Template.%:e autocmd! BufNewFile *.cpp,*.[ch],*.sh,*.java,*.v,*.sv,*.vhd,*.py exec \":call SetTitle()\" function! SetTitle() \"如果文件类型为脚本文件 if &amp;filetype =~ 'sh\\|perl\\|python' if &amp;filetype == 'sh' call setline(1,\"#!/bin/bash\") elseif &amp;filetype == 'perl' call setline(1,\"#!/usr/bin/perl -w\") elseif &amp;filetype == 'python' call setline(1,\"#!/usr/bin/env python\") endif call append(line(\".\"), \"\") elseif &amp;filetype =~ 'verilog\\|systemverilog\\|c\\|cpp' call setline(1 , \"\\//------------------------------------------------------------------------\") call append(line(\".\") , \"\\// File Name : \".expand(\"%\")) call append(line(\".\")+1 , \"\\// Author : victor dong (dxs_uestc@163.com)\") call append(line(\".\")+2 , \"\\// Version : V0.1 \") call append(line(\".\")+3 , \"\\//------------------------------------------------------------------------\") call append(line(\".\")+4 , \"\\// Description :\" ) call append(line(\".\")+5 , \"\\// \" ) call append(line(\".\")+6 , \"\\//------------------------------------------------------------------------\") call append(line(\".\")+7 , \"\\// Revision History:\" ) call append(line(\".\")+8 , \"\\// *Version* | *Modifier* | *Modified Date* | *Description*\") call append(line(\".\")+9 , \"\\// V0.1 | Victor | \".strftime(\"%Y-%m-%d\").\" | Fisrt Created.\") call append(line(\".\")+10, \"\\//------------------------------------------------------------------------\") call append(line(\".\")+11, \"\" ) endif if &amp;filetype == 'cpp' call append(line(\".\")+12, \"#include&lt;iostream>\") call append(line(\".\")+13, \"using namespace std;\") call append(line(\".\")+14, \"\") endif if &amp;filetype == 'c' call append(line(\".\")+12, \"#include&lt;stdio.h>\") call append(line(\".\")+13, \"\") endif if &amp;filetype =~ 'verilog\\|systemverilog' if expand(\"%:r\") =~ 'tb$' call append(line(\".\")+12, \"`timescale 1ns/1ps\") call append(line(\".\")+13, \"\") call append(line(\".\")+14, \"module \".expand(\"%:r\").\"();\") call append(line(\".\")+15, \"\") call append(line(\".\")+16, \"initial begin\") call append(line(\".\")+17, \" $fsdbDumpfile(\\\"wave.fsdb\\\");\") call append(line(\".\")+18, \" $fsdbDumpvars(0);\") call append(line(\".\")+19, \"\\// $fsdbDumpMDA(0);\") call append(line(\".\")+20, \"end\") call append(line(\".\")+21, \"\") call append(line(\".\")+22, \"endmodule\") else call append(line(\".\")+12, \"module \".expand(\"%:r\").\"(\") call append(line(\".\")+13, \" input clk ,\") call append(line(\".\")+14, \" input rst_n ,\") call append(line(\".\")+15, \");\") call append(line(\".\")+16, \"\") call append(line(\".\")+17, \"\\//==============================================\") call append(line(\".\")+18, \"\\// Definition of regs and wires\") call append(line(\".\")+19, \"\\//==============================================\") call append(line(\".\")+20, \"\") call append(line(\".\")+21, \"\\//**********************************************\") call append(line(\".\")+22, \"\\// Function\") call append(line(\".\")+23, \"\\//**********************************************\") call append(line(\".\")+24, \"\") call append(line(\".\")+25, \"endmodule\") endif endif \"新建文件后，自动定位到文件末尾 exec \"normal G\" endfunc \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"实现上面函数中的，Last Modified功能 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"autocmd! BufWrite,BufWritePre,FileWritePre *.cpp,*.[ch],*.sh,*.java,*.v,*.sv,*.vhd,*.py ks|call LastModified()|'s \"function! LastModified() \" if line(\"$\") > 20 \" let l = 20 \" else \" let l = line(\"$\") \" endif \" exec \"1,\".l.\"g/Last Modified: /s/Last Modified: .*/Last Modified:\". \" \\strftime(\" %Y-%m-%d %H:%M:%S\") . \"/e\" \"endfunc \" Returns true if paste mode is enabled function! HasPaste() if &amp;paste return '[PASTE MODE] ' endif return '' endfunction \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" return vim mode \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" function! Disp_Mode() let mode=mode() if mode ==# 'v' return 'Visual' elseif mode ==# 'V' return 'V-Line' elseif mode ==# '\u0016' return 'V-Block' elseif mode ==# 's' return 'Select' elseif mode ==# 'S' return 'S-Line' elseif mode ==# '\u0013' return 'S-Block' elseif mode =~# '\\vi' return 'Insert' elseif mode =~# '\\v(R|Rv)' return 'Replace' else return 'Normal' endif endfunction \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" add comment and del comment \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" autocmd BufNewFile,BufRead * map &lt;C-c> :call AddComment()&lt;CR> autocmd BufNewFile,BufRead * map &lt;S-c> :call DelComment()&lt;CR> function! AddComment() if &amp;filetype =~? 'python\\|perl\\|tcl\\|sh\\|zsh\\|csh\\|conf\\|sdc\\|make' exec 's/\\v^(\\s*)#*/#\\1/' elseif &amp;filetype =~? 'verilog\\|c\\|cpp\\|h' exec 's/\\v^(\\s*)\\/*/\\/\\/\\1/' elseif &amp;filetype ==? 'vhdl' exec 's/\\v^(\\s*)-*/--\\1/' elseif &amp;filetype ==? 'vim' exec 's/\\v^(\\s*)\\\"*/\\\"\\1/' elseif &amp;filetype == 'xml' exec 's/\\v^(.*)$/&lt;!--\\1-->' endif exec \"nohl\" endfunction function! DelComment() if &amp;filetype =~? 'python\\|perl\\|tcl\\|sh\\|zsh\\|csh\\|conf\\|sdc\\|make' exec 's/\\v^(\\s*)#*/\\1/' elseif &amp;filetype =~? 'verilog\\|c\\|cpp\\|h' exec 's/\\v^(\\s*)\\/*/\\1/' elseif &amp;filetype ==? 'vhdl' exec 's/\\v^(\\s*)-*/\\1/' elseif &amp;filetype ==? 'vim' exec 's/\\v^(\\s*)\\\"*/\\1/' elseif &amp;filetype == 'xml' exec 's/\\v^%(\\s*\\&lt;\\!--)*(.*)%(-->\\s*)*$/\\1/' endif exec \"nohl\" endfunction \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" filetype \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" au BufNewFile,BufRead readme,README setf help \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" plugin: supertab \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" let g:SuperTabDefaultCompletionType = \"context\" let g:SuperTabMappingForward = '&lt;s-space>' let g:SuperTabMappingBackward = '&lt;s-c-space>' \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" plugin: NERDTree \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"autocmd vimenter * NERDTree autocmd bufenter * if (winnr(\"$\") == 1 &amp;&amp; exists(\"b:NERDTreeType\") &amp;&amp; b:NERDTreeType == \"primary\") | q | endif map &lt;F3> :NERDTreeToggle&lt;CR> let NERDTreeShowHidden=0 let NERDTreeWinSize=25 let NERDTreeIgnore=['\\~$', '\\.swap$', '.pyc$'] \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" plugin: UltiSnips \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" let g:UltiSnipsExpandTrigger=\"&lt;tab>\" let g:UltiSnipsJumpForwardTrigger=\"&lt;tab>\" let g:UltiSnipsJumpBackwardTrigger=\"&lt;c-b>\" \" If you want :UltiSnipsEdit to split your window. let g:UltiSnipsEditSplit=\"vertical\"","categories":[{"name":"vim","slug":"vim","permalink":"https://dxsm.github.io/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://dxsm.github.io/tags/vim/"},{"name":"vimrc","slug":"vimrc","permalink":"https://dxsm.github.io/tags/vimrc/"}]},{"title":"IEEE1801 UPF核心要点","slug":"upf-note","date":"2019-01-12T00:04:02.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/upf-note.html","link":"","permalink":"https://dxsm.github.io/p/upf-note.html","excerpt":"CPF, UPF, IEEE1801 这些名称的渊源可参阅《一文读懂power intent的历史：从CPF/UPF到IEEE1801》，1801的内容其实十分简明，概括来说一个完整的1801 文件可以分成三部分[1]： 区域划分: 上帝的归上帝，凯撒的归凯撒，包括supply set 跟power domain 两个东西。 策略定义: 没有清规戒律，何以服众，包括isolation, level shifter, retention, power switch 四种策略。 模式定义: 宿命就是划定的圈，听天由命也是宿命，只有power state.","text":"CPF, UPF, IEEE1801 这些名称的渊源可参阅《一文读懂power intent的历史：从CPF/UPF到IEEE1801》，1801的内容其实十分简明，概括来说一个完整的1801 文件可以分成三部分[1]： 区域划分: 上帝的归上帝，凯撒的归凯撒，包括supply set 跟power domain 两个东西。 策略定义: 没有清规戒律，何以服众，包括isolation, level shifter, retention, power switch 四种策略。 模式定义: 宿命就是划定的圈，听天由命也是宿命，只有power state. 在实际项目中，power domain 的划分有时候会极其复杂，会有多个1801 文件相互调用，但再复杂的设计都是上述三部分内容的集合，在面对复杂设计时，简单有效的办法是：一张图 + 一张表。 一张图：将power domain 及boundary 的关系画出来，就可以十分明确地知道需要定义多少个power domain, 每个power domain 有哪些供电电压，哪些power domain 之间需要isolation 或level shifter, 哪些power domain 需要power switch 跟retention cell. 有了图之后，剩下的事情就是用1801 的命令进行描述。 一张表：用表来描述power state, 先将每一个supply set 的power state 列出，再将系统的power mode 列出。 1. 区域划分 Supply set：从1801 开始引入supply set 的概念，supply set 很像C++ 里的&quot;类&quot;，它将所有相关的supply nets &quot;封装&quot;起来，一个supply set 包含某个instance 或power domain 所有的supply nets。1801 的标准一直在更新，现在最新的应该是IEEE1801-2015, supply set 的定义如下图： Power Domain：在逻辑上看，power domain是一组instance 的集合，集合中所有的instance 共用相同的supply set. 从物理上看，一个power domain 对应一个voltage area, 这个area 内部所有的std cell 用同一组电源和地。 需要特别说明一下 -available_supply 这个option, 默认在&quot;本power domain&quot; 或 “父power domain” 区域定义的supply set 都可供该power domain 所用，但实际项目中，并不能也不需要将所有的power 都拉到该区域，所以需要给工具指明该power domain 需要哪些supply set, 此时就需要用到这个 option: 如果没有指定-available_supply，则在&quot;本power domain&quot; 或 “父power domain” 区域定义的supply set 都可为该power domain 所用； 如果指定-available_supply 且其值为空字符串，如 {} , 那只有-supply 指定的supply set 才可以为本power domain 所用； 如果用-available_supply 指定了某个具体的 supply set, 则该power domain 除了可以用由-supply 指定的supply set 也可以用由该option 指定的supply set. Supply set in Power domain：每创建一个power domain 都会自动创建三个supply sets: Primary：定义该power domain 中所有instance 的primary power 和 primary ground。 Default retention: 用于retention cells. Default isolation：用于isolation cells 也同C++ 中对象的访问类似，可以用 “句柄” 来访问power domain 的supply set, 如：“DomainName.Supply_set”。创建power domain时自动创建的supply sets 需要同电路中的supply net 正确关联起来方可。有如下两种方式： Style1: create_supply_set SS1 -function {power VDD} create_power_domain PD1 –supply {primary SS1} Style2: create_power_domain PD1 create_supply_set SS1 -function {power VDD} associate_supply_set SS1 –handle PD1.primary 2. 策略定义 2.1 Isolation Isolation：当一条net 的driver 在shutoff power domain 而load 在more on power domain 时，该net 在跨power domain 时就需要插入isolation cell. 以保证在shutoff power domain 断电时，more on power domain 的输入被钳位到一个固定电压值而不是一个不定态。Isolation cell 在逻辑功能上可能是『二输入与』也可能是『二输入或』，其中一个输入是控制信号，用于掉电后把输出拉高或拉低，另一个输入为功能信号。通常有双电源跟单电源两种isolation cell, 双电源isolaiton cell 可以放入shutoff power domain, 一组电源接shutoff power 另一组电源接backup 电源；而单电源isolation cell 只能放入more on power domain 或more more on parents power domain. 不同的工具都在跟着IEEE 1801 标准的更新不断改进，并不是所有的工具都支持所有的option, 其实大部分isolation 的定义都不需要所有的option。在UPF1.0 中需要用set_isolation + set_isolation_control 两条命令来定义一条isolation stratage, 即使是到1801 时代，在很长一段时间，有些工具依然需要用两条命令来定义。 定义哪里需要插入 isolation： 从&quot;一张图&quot; 开始，确定需要插入isolation 的interface net. 用下面的option 来定义： 定义如何插入 Isolation： 用如下option 定义： 2.2 Level Shifter Level shifters：当一条net 的driver 跟load 在由不同电压驱动的power domain 时，该net 在跨power domain 时就需要插入level shifter cell，以确保输入信号的电平在合法范围内。通常level shifter cell 有三种：从低到高、从高到低、既能低到高也能高到低。在逻辑功能上 level shifter cell 比isolation cell 简单，就是一个buffer，但是需要两组power supply, 输入power supply 对应于driver 的supply, 输出power supply 对应于load 的supply。 理论上讲，只要net 跨越不同电压驱动的power domain 就需要插入level shifter cell, 但是如果一根信号是从高电压区域到低电压区域，且『高低电压差』在低电压区cell 可忍受范围内，则可以省去该level shifter cell. 但是通常从低电压到高电压，则一定要插入level shifter，否则可能由于电压低于load cell 翻转电压导致功能错误，而且会由于管子不能完全关断会造成持续短路电流。 level shifter rule 的定义也比isolation rule 要简单。 定义哪里需要插入 level shifter: 定义如何插入 level shifter： 2.3 Retention Retention：shut off domain 中有些寄存器非常重要，即便是掉电后其内容也需要被保留住，以保证上电后相关逻辑有个正确的起点，在低功耗设计中这些寄存器会用retention 寄存器来替换，retention 寄存器有多种结构，差别之处主要在控制信号的数目及控制方式，内部结构相差并不大。相比于普通的寄存器Rentention 寄存器内部多了一个有独立电源的latch, 这个独立电源会连到always on supply 上，当主电源掉电后，该Latch 会将寄存器掉电前最后的状态锁存住，当主电源恢复后，再将该Latch 锁存的状态读回。常见的retention cell 有如下几种，此处不展开描述，会另辟章节介绍这些低功耗cell。 Retention rule 比其他几个rule 要复杂一些，在定义retention rule 之前需要确认几点： 去lib 或lib 的doc 中确认要用到的retention cell 的控制信号是哪些，及相应的有效电平。 跟设计人员确认shut off domain 中哪些寄存器需要做retention. 确认retention cell 的backup supply是谁。 哪些寄存器需要retention： 指定retention cell 的backup supply： 指定retention cell 的控制信号： 指定用那种retention cell： 2.4 Power Switch Power Switches：用于控制shut off power domain 电源的开关，power switch 用于控制power net 故跟power plan 相关，在实现时需要精细考虑以尽量减小其造成的IR-drop. 不像其他low power cell 通常需要在综合时插入, power switch cell 是在P&amp;R 工具中插入的。通常power switch cell 有Coarse Grain 和Fine Grain 两种，更常用的是Coarse Grain, 根据切断电流通路的位置它又分Header Switch 跟Footer Switch 两中。Fine Grain 指对每个STD cell 分别关断，这要求每个STD cell 自带一个Switch 管子且有一个控制pin, 在该Domain 不工作时将supply 断开。 常见的Power Switch cell 有一个控制信号或两个控制信号用-control_port 来指定，用-on_state 来定义控制逻辑，如&quot;与或非&quot; 。 -ack_port 所指定的信号用于表示输出电压是否已稳定，这个信号通常用于其他power switch 的输入或状态机的控制。 2.5 Map to specfic cells 在大多数情况下，都需要指定某个isolation 或 level shifter stratage 可用哪些特定的lib cell, 在UPF 1.0 中会用如下命令予以指定： map_isolation_cell -lib_cells &lt;cells list> map_level_shifter_cell -lib_cells &lt;cells list> 在很多用IEEE 1801 描写的UPF 文件中，亦会用这两条命令来指定，一方面是由于工具端更新不及时，另一方面源于用户使用习惯。 在IEEE1801 中定义了新命令：use_interface_cell. 这条命令可以针对某条具体的strategy 来指定。 如果一条net 即需要插入isolation cell 也需要插入 level shifter cell 通常会用到一种带enable pin 的level shifter cell, 这类cell 有两类：一类叫enabled level shifter cell 另一种叫combo cells, 即将isolation cell 跟 level shifter cell 组合到一起的cell, 这两类cell 在library 中的定义不同，用CPF 描述时也不同，用IEEE 1801定义时，需要分别定义isolation rule 跟 level shifter rule, 然后用use_interface_cell 将两条rule 指定到组合的cell 上即可。 3. 模式定义 Power State：power state 是power intent 的&quot;状态机&quot;，用于定义设计中每个power domain 的供电状况，如哪些power domain 开启，哪些power domain 关断，哪些power domain 可工作于多个电压。CPF, UPF, 1801 都有各自定义power state的命令。 CPF: 用create_power_mode 来定义，在CPF 中power state 通常被称为power mode. UPF: 用add_port_state + create_pst + add_pst 来定义，比较繁琐。 1801: 虽然可以用upf 的命令来定义，但是强烈推荐用命令add_power_state 来定义。 如同RTL 写状态机需要画状态转移图一样，在定义power state 之前最好列一张&quot;状态表&quot;，尤其对于复杂设计而言十分必要。如下图，该设计有两个power domain: PDon: 常开电压域，工作电压1.08V，对应的supply set 是VDD + VSS. PD1: 可关断电压域, 工作电压是0.9V, 对应的supply set 是power switch 的输入VDDm + VSS; 跟power switch 的输出VDDau + VSS。 根据power domain 的划分及描述，可以列一张如下的表，列出该设计所有可能的power state 及每个power state 对应supply set 的工作电压。 1801 的power state 定义由supply set level power state 和 system level power state 两级构成。 supply set level power state: 用add_power_state + -supply_expr 定义每个supply set 的工作电压。虽然并不是必须要明确定义supply set 的power state, 但强烈推荐予以明确定义，保证良好的继承性及可读性，所见即所得。 system level power state: 用add_power_state + -logic_expr 定义不同supply set 间的交互。 supply set level power state 的定义需要注意几点： -supply_expr 中只能包含该supply set 对应的net. 在supply_expr 中可用逻辑与&quot;&amp;&amp;&quot; 表示不同supply net的状态。 -simstate 用于simulation, “normal” 对应于ON state, “corrupt” 对应于OFF state. 实现工具自动忽略该option. system level power state 的定义需要注意几点： add_power_state 后跟的object_name，C 跟S 的工具有所不同，对于C家的工具这个object_name 可以是已定义的任何一个power domain 的名字，如示例中的&quot;PDon&quot;；而对于S 家的工具目前还不支持用power domain 做object_name, 需要用命令 create_power_state_group 定义一个state group, 用这个state group 做object_name. 需要在每个-logic_expr 中将所有的supply set 的状态明确给出。 在system level power state 中不要指定-simstate. 整理自陌上风骑驴看IC ↩︎","categories":[{"name":"UPF","slug":"UPF","permalink":"https://dxsm.github.io/categories/UPF/"}],"tags":[{"name":"SOC","slug":"SOC","permalink":"https://dxsm.github.io/tags/SOC/"},{"name":"Low Power","slug":"Low-Power","permalink":"https://dxsm.github.io/tags/Low-Power/"},{"name":"UPF","slug":"UPF","permalink":"https://dxsm.github.io/tags/UPF/"}]},{"title":"AHB协议学习笔记","slug":"ahb_protocal","date":"2018-12-12T14:50:15.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/ahb-protocal.html","link":"","permalink":"https://dxsm.github.io/p/ahb-protocal.html","excerpt":"1. AHB组成部分 AHB主设备(master) 发起一次读写操作 某一时刻只允许一个master使用总线 AHB从设备(slave) 响应一次读写操作 通过地址映射来选择使用哪个slave AHB仲裁器(arbiter) 允许某一个主设备控制总线 在AMBA协议中没有定义仲裁算法 AHB译码器(decoder) 通过地址译码来决定选择哪个slave","text":"1. AHB组成部分 AHB主设备(master) 发起一次读写操作 某一时刻只允许一个master使用总线 AHB从设备(slave) 响应一次读写操作 通过地址映射来选择使用哪个slave AHB仲裁器(arbiter) 允许某一个主设备控制总线 在AMBA协议中没有定义仲裁算法 AHB译码器(decoder) 通过地址译码来决定选择哪个slave 2. AHB信号 Name Source To Desciption HCLK clock Source 各个module 总线时钟 HRESETn reset controller 各个module 总线复位 HADDR[31:0] master decoder/mux to slave/arbiter 32位系统地址总线 HTRANS[1:0] master mux to slave 当前传输类型: IDLE(00),BUSY(01),NONSEQ(10),SEQ(11) HWRITE master mux to slave 0:读, 1:写 HSIZE[2:0] master mux to slave 指示当前传输的大小: 000(8bit),001(16bit),010(32bit),011(64bit)… HBURST[2:0] master mux to slave/arbiter burst类型: single,incr,wrap HPROT[3:0] master mux to slave 保护机制，需要slave带有保护功能 HWDATE[31:0] master mux to slave 写数据总线 HBUSREQx master arbiter 总线接入请求 HLOCKx master arbiter master requires locked access to the bus(no other master should be granted the bus until this signal is LOW) HRDATE[31:0] slave mux to master/arbiter 读数据总线 HREADY slave mux to master/arbiter HREADY拉高表示一次传输完成，HREADY为低电平延长传输周期 HRESP[1:0] slave mux to master/arbiter 传输状态: OKAY, ERROR, RETRY, SPLIT HSPLITx[15:0] slave arbiter 告诉arbiter哪个master允许重新尝试一次split传输 HSELx decoder slave slave片选信号 HGRANTx arbiter master This signal indicates that bus master x is currently the highest priority master. A master gets access to the bus when both HREADY and HGRANTx are HIGH HMASTER[3:0] arbiter 具有split功能的slave 指出哪个master正在进行传输，提供进行split的信息 HMASTLOCK arbiter 具有split功能的slave 指出当前master正在进行一次锁定传输 3. 基本传输 AHB传输有两个阶段： Address phase: 只有一个有效周期 Data phase: 由HBURST信号决定需要几个有效周期 流水线传送：先是address phase，再是data phase。下一次address phase可以与上一次data phase在同一周期。 3.1 无等待周期的简单传输 HCLKHADDR[31:0]AControlControlHWDATA[31:0]Data(A)HREADYHRDATA[31:0]Data(A)Address phaseData phase 3.2 需要等待两个周期的简单传输 slave通过拉低hready信号延长传输周期(协议规定最大不能超过16个周期)，注意： 对于写传输，master在延长周期内必须保持HWDATA数据稳定 对于读传输，slave在延长周期不需要提供有效的HRDATA HCLKHADDR[31:0]AControlControlHWDATA[31:0]Data(A)HREADYHRDATA[31:0]Data(A)Address phaseData phase 3.3 Pipeline传输 HCLKHADDR[31:0]ABCControlControl(A)Control(B)Control(C)HWDATA[31:0]Data(A)Data(B)Data(C)HREADYHRDATA[31:0]Data(A)Data(B)Data(C) 4. burst传输 4.1 传输类型 HTRANS[1:0] Type Description 00 IDLE master占用总线，但没有进行传输 01 BUSY master占用总线，但在burst传输过程中还没有准备好下一次传输，地址和控制信息必须反映下一次传输 10 NONSEQ 表明一次单个数据的传输或者一次burst传输的第一个数据，地址和控制信号与上一次传输无关 11 SEQ 表明burst传输接下来的数据，地址和上一次传输的地址是相关的，控制信息与上一次传输是相同的 4.2 burst类型 HBURST[2:0] Type Desciption 000 SINGLE 单次传输 001 INCR 未定义长度incrementing传输 010 WRAP4 4-beat wraping burst 011 INCR4 4-beat incrementing burst 100 WRAP8 8-beat wraping burst 101 INCR8 8-beat incrementing burst 110 WRAP16 16-beat wraping burst 111 INCR16 16-beat incrementing burst 4.3 未定义长度INCR传输 INCR传输HADDR累加值与HSIZE有关，每次加2HSIZE Burst传输不能跨越1K边界，即到达1K边界需要用NONSEQ发起一次新的传输 ❓思考：为什么burst传输不能跨越1K边界？ ARM的回答：The 1KB restriction you refer to is not a restriction on maximum slave size but a constraint within AHB that says that a burst must not cross a 1KB boundary. The limit is designed to prevent bursts crossing from one device to another and to give a reasonable trade-off between burst size and efficiency. In practise, this means that a master must ALWAYS break a burst that would otherwise cross the 1KB boundary and restart it with a non-sequential transfer. 图4.3.1 未定义长度INCR传输HCLKHTRANS[1:0]NONSEQSEQNONSEQSEQSEQHADDR[31:0]0x200x220x5C0x600x64HBURST[2:0]INCRINCRHSIZE[2:0]001010HWDATA[31:0]Data(0x20)Data(0x22)Data(0x5C)Data(0x60)Data(0x64)HREADYHRDATA[31:0]Data(0x20)Data(0x22)Data(0x5C)Data(0x60)Data(0x64) 图4.3.2 未定义长度INCR跨1K边界HCLKHTRANS[1:0]NONSEQSEQSEQNONSEQSEQSEQHADDR[31:0]0x3F40x3F80x3FC0x4000x4040x408HBURST[2:0]INCRHSIZE[2:0]010HWDATA[31:0]Data(0x3F4)Data(0x3F8)Data(0x3FC)Data(0x400)Data(0x404)Data(0x408)HREADYHRDATA[31:0]Data(0x3F4)Data(0x3F8)Data(0x3FC)Data(0x400)Data(0x404)Data(0x408) 4.4 WRAP传输 ❓思考：如何确定WRAP边界？ wrap的边界与HSIZE和HBURST都有关系，对于WRAP4来说，HADDR[HSIZE+1:HSIZE]==2’b11就是边界；对于WRAP8来说，HADDR[HSIZE+2:HSIZE]==2’b111就是边界，同理适用于WRAP16。 假如：HSIZE=3’b010时，HADDR起始地址为0x48 当HBURST为WRAP4时，HADDR依次为0x48 -&gt; 0x4C -&gt; 0x40 -&gt; 0x44(对应的HADDR[3:2]依次为2’b10 -&gt; 2’b11 -&gt; 2’b00 -&gt; 2’b01) 当HBURST为WRAP8时，HADDR依次为0x48 -&gt; 0x4C -&gt; 0x50 -&gt; 0x54 -&gt; 0x58 -&gt; 0x5C -&gt; 0x40 -&gt; 0x44(对应的HADDR[4:2]依次为3’b010 -&gt; 3’b011 -&gt; 3’b100 -&gt; 3’b101 -&gt; 3’b110 -&gt; 3’b111 -&gt; 3’b000 -&gt; 3’b001) 图4.4.1 WRAP4传输HCLKHTRANS[1:0]NONSEQSEQSEQSEQHADDR[31:0]0x480x4C0x400x44HBURST[2:0]WRAP4HSIZE[2:0]010HWDATA[31:0]Data(0x48)Data(0x4C)Data(0x40)Data(0x44)HREADYHRDATA[31:0]Data(0x48)Data(0x4C)Data(0x40)Data(0x44) 5. 总结 slave短时间内无法响应：将HREADY拉低 slave长时间无法响应：插入SPIT/RETRY master不能传输，插入BUSY 总线上如果只有一个master，可以使用AHB lite协议，即没有arbiter，不支持retry和split响应 AHB中hready的含义 对于slave来说,进来的hready_i代表的是bus上的状态低就表示bus被人(可能是他自己)使用着,hready_o代表它自身的状态,低代表它要占用bus 对于arbiter来说,从slave进来的hready_i代表各个slave占用bus的状态,返回给slave的hready是所有的hready_i做and运算之后的结果,同时这个也返回给master 对于master来说,hready_i拉低代表bus忙,不能使用","categories":[{"name":"SOC设计","slug":"SOC设计","permalink":"https://dxsm.github.io/categories/SOC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"AMBA","slug":"AMBA","permalink":"https://dxsm.github.io/tags/AMBA/"},{"name":"SOC","slug":"SOC","permalink":"https://dxsm.github.io/tags/SOC/"},{"name":"AHB","slug":"AHB","permalink":"https://dxsm.github.io/tags/AHB/"}]},{"title":"testbench如何force vhdl内部信号","slug":"nc_force_usage","date":"2018-10-02T14:50:15.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/nc-force-usage.html","link":"","permalink":"https://dxsm.github.io/p/nc-force-usage.html","excerpt":"force verilog内部信号 force verilog内部信号为某个值，可以这样写： initial begin //verilog internal signal access force xxx.xxx.xxx = 16'hfffd; #500 release xxx.xxx.xxx; end force vhdl内部信号 而对于vhdl内部信号，使用force是错误的，vhdl语言不允许这样做。但是EDA工具一般都会提供函数，例如cadence的ncsim，可以使用$nc_force和nc_release访问vhdl内部信号。 initial begin //vhdl internal signal access $nc_force(\"xxx.xxx.xxx\", \"X'FFFD'\"); #500 $nc_release(xxx.xxx.xxx); end","text":"force verilog内部信号 force verilog内部信号为某个值，可以这样写： initial begin //verilog internal signal access force xxx.xxx.xxx = 16'hfffd; #500 release xxx.xxx.xxx; end force vhdl内部信号 而对于vhdl内部信号，使用force是错误的，vhdl语言不允许这样做。但是EDA工具一般都会提供函数，例如cadence的ncsim，可以使用$nc_force和nc_release访问vhdl内部信号。 initial begin //vhdl internal signal access $nc_force(\"xxx.xxx.xxx\", \"X'FFFD'\"); #500 $nc_release(xxx.xxx.xxx); end cadence工具debug小技巧 使用cadence工具编译出错，看不懂error解释时，可以使用nchelp获取更详细的解释或解决办法。例如编译时出现如下错误： 可以在terminal敲入命令nchelp ncsim SETNEL得到详细帮助如下：","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"testbench","slug":"testbench","permalink":"https://dxsm.github.io/tags/testbench/"}]},{"title":"systemverilog面向对象","slug":"sv_learning_chap4","date":"2018-09-30T14:50:15.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/sv-learning-chap4.html","link":"","permalink":"https://dxsm.github.io/p/sv-learning-chap4.html","excerpt":"类封装了数据和操作这些数据的子程序 类可以定义在program、package、module中，或者在这些块之外的任何地方。类应当在program或者module之外的package中定义，避免与其他块内变量出现冲突。 new()创建对象、分配空间并执行构造函数 赋值为null释放对象空间 通过static来声明静态变量，是的该变量被该类的所有实例所共享，但使用范围仅限于该类 通过类名::变量来访问静态变量 静态变量在声明时初始化 静态方法跟静态变量类似，也通过static声明 静态方法不允许读写非静态变量 类中的方法默认是自动存储的 当使用一个变量时，会优先在当前作用域中寻找，接着在上一级作用域寻找，直到找到该变量为止。this可以明确指定当前作用域。","text":"类封装了数据和操作这些数据的子程序 类可以定义在program、package、module中，或者在这些块之外的任何地方。类应当在program或者module之外的package中定义，避免与其他块内变量出现冲突。 new()创建对象、分配空间并执行构造函数 赋值为null释放对象空间 通过static来声明静态变量，是的该变量被该类的所有实例所共享，但使用范围仅限于该类 通过类名::变量来访问静态变量 静态变量在声明时初始化 静态方法跟静态变量类似，也通过static声明 静态方法不允许读写非静态变量 类中的方法默认是自动存储的 当使用一个变量时，会优先在当前作用域中寻找，接着在上一级作用域寻找，直到找到该变量为止。this可以明确指定当前作用域。","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"systemverilog","slug":"systemverilog","permalink":"https://dxsm.github.io/tags/systemverilog/"}]},{"title":"systemverilog接口以及搭建测试环境","slug":"sv_learning_chap3","date":"2018-09-29T14:50:15.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/sv-learning-chap3.html","link":"","permalink":"https://dxsm.github.io/p/sv-learning-chap3.html","excerpt":"接口信号必须使用非阻塞赋值来驱动 modport将信号分组并指定方向 clocking时钟块用于控制同步信号的时序 testbench注意事项： $exit用于结束程序块，$finish用于结束仿真 时钟产生不应该放在program程序块中，会引起信号的竞争，而应该放在module中 例化时如果端口名字和数据类型一致，例化时可以用.*(隐式端口连接) DUT代码 以简单的乘法器为例写testbench //mul.v module mul( input clk, input rst_n, input in_vld, input [11:0] mul_ain, input [11:0] mul_bin, output reg [22:0] mul_out, output reg out_vld ); always @(posedge clk) if(in_vld) mul_out &lt;= $signed(mul_ain) * $signed(mul_bin); always @(posedge clk,negedge rst_n) if(!rst_n) out_vld &lt;= 1'b0; else out_vld &lt;= in_vld; endmodule","text":"接口信号必须使用非阻塞赋值来驱动 modport将信号分组并指定方向 clocking时钟块用于控制同步信号的时序 testbench注意事项： $exit用于结束程序块，$finish用于结束仿真 时钟产生不应该放在program程序块中，会引起信号的竞争，而应该放在module中 例化时如果端口名字和数据类型一致，例化时可以用.*(隐式端口连接) DUT代码 以简单的乘法器为例写testbench //mul.v module mul( input clk, input rst_n, input in_vld, input [11:0] mul_ain, input [11:0] mul_bin, output reg [22:0] mul_out, output reg out_vld ); always @(posedge clk) if(in_vld) mul_out &lt;= $signed(mul_ain) * $signed(mul_bin); always @(posedge clk,negedge rst_n) if(!rst_n) out_vld &lt;= 1'b0; else out_vld &lt;= in_vld; endmodule interface代码 //mul_if.sv interface mul_if(input bit clk); logic clk; logic rst_n; logic in_vld; logic [11:0] mul_ain; logic [11:0] mul_bin; logic [22:0] mul_out; logic out_vld; //define clock block clocking cb(@posedge clk); output in_vld; output mul_ain; output mul_bin; endclocking //Driver port direction modport DRV( clocking cb, output rst_n ); //DUT port direction modport DUT( input rst_n, input in_vld, input mul_ain, input mul_bin, output mul_out, output out_vld ); endinterface Driver代码 //driver.sv program driver(mul_if.DRV mulif); initial begin //reset value mulif.rst_n &lt;= 1'b0; mulif.cb.in_vld &lt;= 1'b0; //release reset #37 mulif.rst_n &lt;= 1'b1; repeat(10) begin ##1 mulif.cb.in_vld &lt;= 1'b1; //drive data @(posedge clk), ##1 means delay 1 clock mulif.cb.mul_ain &lt;= $random; mulif.cb.mul_bin &lt;= $random; end ##1 mulif.cb.in_vld &lt;= 1'b0; repeat(5) @mulif.cb; //wait posedge clk $finish; end endprogram tb_top代码 //tb_top.sv module tb_top(); bit clk; always #5 clk = ~clk; mul_if mulif(clk); driver u_drv(mulif); mul u_mul( .clk (clk), .rst_n (mulif.DUT.rst_n), .in_vld (mulif.DUT.in_vld), .mul_ain (mulif.DUT.mul_ain), .mul_bin (mulif.DUT.mul_bin), .mul_out (mulif.DUT.mul_out), .out_vld (mulif.DUT.out_vld) ) initial begin $fsdbDumpfile(\"wave.fsdb\"); $fsdbDumpvars(0); end endmodule 仿真波形","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"systemverilog","slug":"systemverilog","permalink":"https://dxsm.github.io/tags/systemverilog/"}]},{"title":"systemverilog任务、函数、program","slug":"sv_learning_chap2","date":"2018-09-28T14:50:15.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/sv-learning-chap2.html","link":"","permalink":"https://dxsm.github.io/p/sv-learning-chap2.html","excerpt":"缺省情况下参数的类型是与其前一个参数相同的，而第一个参数的缺省类型是logic单bit输入 参数的传递方式可以使用ref指定为引用，通常用于数组引用；当不希望子程序改变数组值时，可以使用const ref类型 ref参数只能被用于带自动存储(automatic)的子程序中，即使用ref参数时子程序必须指明automatic属性 自动存储相对的是静态存储，当多个地方调用静态存储子程序时，不同的线程之间会窜用这些局部变量，而自动存储能够迫使仿真器使用堆栈存储局部变量 函数使用return返回一个值，调用时可以使用void忽略返回值，例如void'($fscanf(file,&quot;%d&quot;,i)); module test_func(); int arr[]; //************************************ // operator = \"+\", return a.sum // operator = \"x\", return a.product //************************************ function automatic int alu( const ref int a[], //数组引用,const不能改变数组 input string operator = \"+\" //指定default值 ); int result; if(operator==\"x\") begin result = 1; for(a[i]) result *= a[i]; end else begin result = 0; for(a[i]) result += a[i]; end return result; endfunction initial begin arr = new[5]; arr = '{1,2,3,4,5}; $display(alu(arr)); //15, use default operator $display(alu(arr,\"x\")) //120 end endmodule","text":"缺省情况下参数的类型是与其前一个参数相同的，而第一个参数的缺省类型是logic单bit输入 参数的传递方式可以使用ref指定为引用，通常用于数组引用；当不希望子程序改变数组值时，可以使用const ref类型 ref参数只能被用于带自动存储(automatic)的子程序中，即使用ref参数时子程序必须指明automatic属性 自动存储相对的是静态存储，当多个地方调用静态存储子程序时，不同的线程之间会窜用这些局部变量，而自动存储能够迫使仿真器使用堆栈存储局部变量 函数使用return返回一个值，调用时可以使用void忽略返回值，例如void'($fscanf(file,&quot;%d&quot;,i)); module test_func(); int arr[]; //************************************ // operator = \"+\", return a.sum // operator = \"x\", return a.product //************************************ function automatic int alu( const ref int a[], //数组引用,const不能改变数组 input string operator = \"+\" //指定default值 ); int result; if(operator==\"x\") begin result = 1; for(a[i]) result *= a[i]; end else begin result = 0; for(a[i]) result += a[i]; end return result; endfunction initial begin arr = new[5]; arr = '{1,2,3,4,5}; $display(alu(arr)); //15, use default operator $display(alu(arr,\"x\")) //120 end endmodule program program与module相同点 和module相同，program也可以定义0个或多个输入、输出、双向端口。 一个program块内部可以包含0个或多个initial块、generate块、specparam语句、连续赋值语句、并发断言、timeunit声明。 在program块中数据类型、数据声明、函数和任务的定义均与module块类似。 一个设计中可以包含多个program块，这些program块既可以通过端口交互，也可以相互独立，这一点与module块也是相似的。 program与module不同点 一个program块不能包含任何always块，用户自定义原语(UDP)，module块、接口(interface)、program块 module中可以定义program块 一个program块可以调用其他module块或者program块中定义的函数或任务，但是一个module块却不能调用其他program块中定义的任务或函数。 program块中变量只能用阻塞赋值，不能使用非阻塞赋值","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"systemverilog","slug":"systemverilog","permalink":"https://dxsm.github.io/tags/systemverilog/"}]},{"title":"systemverilog基础","slug":"sv_learning_chap1","date":"2018-09-27T14:50:15.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/sv-learning-chap1.html","link":"","permalink":"https://dxsm.github.io/p/sv-learning-chap1.html","excerpt":"1. 内建数据类型 四状态：reg, wire, logic, integer, time(默认值为X) 双状态：bit, int, byte, shortint, longint, real(默认值为0) 有符号数：int, byte, shortint, longint, integer(可以使用unsigned申明为无符号数) 🔖 $isunknown操作符: 作用：使用$isunknown操作符，可以在表达式的任意位出现X或Z时返回1 //test_isunknown.sv module test_isunknown(); logic [3:0] din; initial begin din = 4'b1001; //Unknown not found! din = 4'b1x01; //Unknown is detected! din = 4'b1z01; //Unknown is detected! if($isunknown(din)) $display(\"Unknown is detected!\"); else $display(\"Unknown not found!\"); end endmodule","text":"1. 内建数据类型 四状态：reg, wire, logic, integer, time(默认值为X) 双状态：bit, int, byte, shortint, longint, real(默认值为0) 有符号数：int, byte, shortint, longint, integer(可以使用unsigned申明为无符号数) 🔖 $isunknown操作符: 作用：使用$isunknown操作符，可以在表达式的任意位出现X或Z时返回1 //test_isunknown.sv module test_isunknown(); logic [3:0] din; initial begin din = 4'b1001; //Unknown not found! din = 4'b1x01; //Unknown is detected! din = 4'b1z01; //Unknown is detected! if($isunknown(din)) $display(\"Unknown is detected!\"); else $display(\"Unknown not found!\"); end endmodule 2. 数组 2.1 数组初始化、比较、 复制、循环 循环使用for或foreach //test_array.sv module test_array(); // array initial int mem1[4] = '{1,2,3,4}; int mem2[4] = '{4{8}}; //'{8,8,8,8} //int mem3[5] = '{9,8,default:1}; //'{9,8,1,1,1} my eda tool does not support int arr[4][4] = '{ '{0,1,2,3}, '{1,2,3,4}, '{2,3,4,5}, '{3,4,5,6} }; initial begin //array compare $display(\"mem1 %s mem2\", (mem1==mem2) ? \"==\" : \"!=\"); //mem1 != mem2 //array copy mem2 = mem1; $display(\"mem1 %s mem2\", (mem1==mem2) ? \"==\" : \"!=\"); //mem1 == mem2 //array loop $display({20{\"=\"}}); //seperate line foreach(arr[i][j]) $display(\"arr[%0d][%0d] = %0d\", i, j, arr[i][j]); $display({20{\"=\"}}); //seperate line foreach(arr[i]) begin foreach(arr[,j]) if(j>=i) $write(\"%3d\",arr[i][j]); else $write(\"%3s\",\"\"); $display; end end endmodule 运行结果如下： 2.2 动态数组 分配空间new[] 分配空间并复制new[](arr) 释放空间arr.delete() 当数组(动态或定宽)复制给一个动态数组时，会调用构造函数new[]分配空间并复制数据 $size(arr)返回数组宽度 module dyn_array(); // declare and initial int dyn[]; int arr[3] = '{9,7,8}; initial begin //分配空间 dyn = new[5]; foreach(dyn[i]) dyn[i] = i; //'{1,2,3,4,5} //分配空间并复制 dyn = new[10](dyn); //'{1,2,3,4,5,0,0,0,0,0} dyn = arr; //'{9,7,8} //重新分配空间，旧值不复存在 dyn = new[3]; //'{0,0,0} //释放空间 dyn.delete(); $display($size(dyn)); //0 end endmodule 2.3 队列 声明q[$] $表示队列索引的最大值或最小值，[$:2]代表[0:2]，[1: ​$]代表[1: ​$size(q)-1]，不是所有仿真器都支持$表示最小值 q.insert(idx,value), 在idx之前插入元素或者队列，不是所有仿真器都支持插入队列 q.delete(idx), 删除第idx个元素 q.push_front(value), 在队列前面插入元素，等价于q={value,q} q.push_back(value), 在队列末尾插入元素，等价于q={q,value} q.pop_front, 从队列前面移出元素，等价于j=q[0]; q=q[1: $] q.pop_back, 从队列末尾移出元素，等价于j=q[$]; q=q[0: $-1] q.delete(), 清空队列，等价于q={} 可以把定宽或动态数组复制给队列 队列遍历也可以使用for和foreach module queue(); // declare and initial int q[$] = {0,2,5}; int q1[$] = {3,4}; int arr[4] = '{9,8,7,6}; int j = 1; initial begin q.insert(1,j); //{0,1,2,5} //q.insert(3,q1); //{0,1,2,3,4,5}, my eda tool does not support insert queue q = {q[0:2],q1,q[$]}; //{0,1,2,3,4,5}, use concat instead of insert function q.delete(1); //{0,2,3,4,5} q.push_front(6); //{6,0,2,3,4,5} q.push_back(8); //{6,0,2,3,4,5,8} j = q.pop_front; //{0,2,3,4,5,8}, j=6 j = q.pop_back; //{0,2,3,4,5}, j=8 q = arr; //{9,8,7,6}, copy array to queue q.delete(); //empty queue $display(\"%0d\", $size(q)); //0 end endmodule 2.4 数组常用方法 arr.sum, 返回数组所有元素和 arr.product, 返回数组所有元素积 arr.and, 返回数组所有元素的与 arr.or, 返回数组所有元素的或 arr.xor, 返回数组所有元素的异或 arr.min(), 返回数组中的最小值队列(注意：返回的是队列，而不是标量) arr.max(), 返回数组中的最大值队列(注意：返回的是队列，而不是标量) arr.unique(), 返回数组中具有唯一值的队列 arr.find with (condition), 返回满足条件元素的队列 arr.find_index with (condition), 返回满足条件元素下标的队列 arr.find_first with (condition), 返回满足条件第一个元素的队列 arr.find_first_index with (condition), 返回满足条件第一个元素下标的队列 arr.find_last with (condition), 返回满足条件第最后一个元素的队列 arr.find_last_index with (condition), 返回满足条件最后一个元素下标的队列 arr.reverse(), 数组反向 arr.sort(), 数组从小到大排序 arr.rsort(), 数组从大到小排序 arr.shuffle(), 数组打乱顺序 其中reverse和shuffle方法不能带with条件语句，它们的作用范围是整个数组 module array(); int arr[] = '{9,1,8,6,3,4,6,11,4}; int q[$]; initial begin //reduce operator(return value) $display(arr.sum); //52 $display(arr.product); //1368576 $display(arr.and); //0 $display(arr.or); //15 $display(arr.xor); //8 //min,max,unique(return queue) q = arr.min(); //{1} q = arr.max(); //{11} q = arr.unique(); //{9,1,8,6,3,4,11} //find operator(return queue) q = arr.find with (item>3); //{9,8,6,4,6,11,4} q = arr.find_index(x) with (x>3); //{0,2,3,5,6,7,8}, with的默认变量为item，也可以改为其他的 q = arr.find_first with (item&lt;4); //{1} q = arr.find_first_index with (item==6); //{3} q = arr.find_last with (item&lt;4); //{3} q = arr.find_last_index with (item==6); //{6} //sort operator(array changed) arr.reverse(); //{4,11,6,4,3,6,8,1,9} arr.sort(); //{1,3,4,4,6,6,8,9,11} arr.rsort(); //{11,9,8,6,6,4,4,3,1} arr.shuffle(); //{9,6,3,4,4,11,6,1,8}, 不同仿真器洗牌的结果是否一致？ end endmodule 3. 字符串 s.getc(N), 返回位置N上的字节 s.tolower(), 返回所有字符小写字符串 s.toupper(), 返回所有字符大写字符串 s.putc(N,C), 将字节C写到字符串的N位，N必须在0~len-1之间 s.substr(start,end), 返回从start到end之间所有字符 s.len(), 返回字符串长度 $psprintf(), 返回一个格式化的临时字符串，可以直接传递给其他子函数 module test_string(); string s; initial begin s = \"IEeE \"; $display(\"%s\", s.getc(0)); //I $display(s.tolower()); //ieee s = s.toupper(); //IEEE s.putc(s.len()-1, \"-\"); //IEEE- s = {s, \"P1800\"}; //IEEE-P1800 $display(s.substr(2,5)); //EE-P $display($psprintf(\"%s %0d\",s,42)); //IEEE-P1800 42 end endmodule","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"systemverilog","slug":"systemverilog","permalink":"https://dxsm.github.io/tags/systemverilog/"}]},{"title":"ASIC设计经典笔试题收录","slug":"asic_design_example","date":"2018-09-26T14:50:15.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/asic-design-example.html","link":"","permalink":"https://dxsm.github.io/p/asic-design-example.html","excerpt":"时序优化题 问：CLK-&gt;Q的时间为0.5ns，组合逻辑cm0、cm1延时均为7ns，在不增加流水线数目(pipeline stage)的前提下，怎么修改电路，才能让CLK达到100MHZ？(提示：C宽为2bit)","text":"时序优化题 问：CLK-&gt;Q的时间为0.5ns，组合逻辑cm0、cm1延时均为7ns，在不增加流水线数目(pipeline stage)的前提下，怎么修改电路，才能让CLK达到100MHZ？(提示：C宽为2bit) 答：放置4个cm1，分别用定值00、01、10、11作为输入，在D前放置4-to-1 Mux，将cm0输出作为选择信号，目的是将cm1的7ns替换为Mux Cell的延时。(逻辑复制，面积换时间)","categories":[{"name":"ASIC设计","slug":"ASIC设计","permalink":"https://dxsm.github.io/categories/ASIC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://dxsm.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"}]},{"title":"EDA工具使用","slug":"eda_irun","date":"2018-09-25T12:46:02.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/eda-irun.html","link":"","permalink":"https://dxsm.github.io/p/eda-irun.html","excerpt":"cadence irun命令 常用编译 irun +access+wr -smartorder -clean -ntcnotchks -V93 -vtimescale 1ns/1ps -work chip_lib -f xxx.vc -top tb_top -64 coverage选项 -covtest xxx -coverage all -covoverwrite -covfile covfile.ccf -covworkdir ./cov_work 其中covfile.ccf定义coverage内容 set_expr_scoring -all set_fsm_scoring -hold_tansition set_libcell_scoring set_implicit_block_scoring -off set_covergroup -per_instance_default_one select_coverage -all -instance tb_top.xxx*...","text":"cadence irun命令 常用编译 irun +access+wr -smartorder -clean -ntcnotchks -V93 -vtimescale 1ns/1ps -work chip_lib -f xxx.vc -top tb_top -64 coverage选项 -covtest xxx -coverage all -covoverwrite -covfile covfile.ccf -covworkdir ./cov_work 其中covfile.ccf定义coverage内容 set_expr_scoring -all set_fsm_scoring -hold_tansition set_libcell_scoring set_implicit_block_scoring -off set_covergroup -per_instance_default_one select_coverage -all -instance tb_top.xxx*... Synopsys Verdi vhdlcom -v93 -sup_sem_error -smartorder -work chip_lib -f vhdl.flist vericom -sv +systemverilogext+sv +v95ext+v95 +verilog2001ext+v -ignorekwd_config -work chip_lib -f verilog.flist verdi -lib chip_lib -top xxx -ssf xxx.fsdb cadence imc命令 coverage merge: imc -exec cov_merge.tcl 其中cov_merge.tcl如下： merge -runfile runfile -metrics code:fsm:block:expression:toggle:assertion:covergroup -out merge_data -overwrite -message 1 -initial_model union_all load -run merge_data report -detail -html -showempty on -overwrite -grading covered -source on -out nc_cov_report 其中runfile列出需要merge的coverage路径 ./cov_work/scope/case1 ./cov_work/scope/case2 ./cov_work/scope/case3* NaN","categories":[{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/categories/eda-tools/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/tags/eda-tools/"}]},{"title":"Linux小技巧","slug":"linux_tips","date":"2018-09-24T14:50:15.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/linux-tips.html","link":"","permalink":"https://dxsm.github.io/p/linux-tips.html","excerpt":"1. 一行执行多条命令 分号 ： 顺序地独立执行各条命令， 彼此之间不关心是否失败， 所有命令都会执行。 &amp;&amp; ： 顺序执行各条命令， 只有当前一个执行成功时候， 才执行后面的。 || ： 顺序执行各条命令， 只有当前面一个执行失败的时候， 才执行后面的。 2. 搜索已经使用的命令 ctrl+r 先按ctrl+r，然后输入要搜索的字符串即可。","text":"1. 一行执行多条命令 分号 ： 顺序地独立执行各条命令， 彼此之间不关心是否失败， 所有命令都会执行。 &amp;&amp; ： 顺序执行各条命令， 只有当前一个执行成功时候， 才执行后面的。 || ： 顺序执行各条命令， 只有当前面一个执行失败的时候， 才执行后面的。 2. 搜索已经使用的命令 ctrl+r 先按ctrl+r，然后输入要搜索的字符串即可。 3. 读压缩后的文件 读log文件常用的命令有cat、less、tail、grep等，但如果文件被压缩了，这些命令读出来的就是乱码，我们可以使用zcat、zless、zgrep等命令读取压缩的文本文件。 4. 获取上次命令的last item(!$) 可以使用!$获取上次命令的选项 5. 获取上次命令(!!) 可以使用!!获取上次命令","categories":[{"name":"Linux","slug":"Linux","permalink":"https://dxsm.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://dxsm.github.io/tags/Linux/"}]},{"title":"孩子教养推荐书籍","slug":"education_book","date":"2018-09-23T14:50:15.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/education-book.html","link":"","permalink":"https://dxsm.github.io/p/education-book.html","excerpt":"父母效能训练手册 9.1 (583人评价) 作者: 戈登 出版社: 天津社会科学院出版社 出版年: 2009-6-1 评语：即P.E.T，经典的亲子沟通图书。系统解决亲子沟通协商的难题。 正面管教 8.8 (1607人评价) 作者: [美] 简·尼尔森 (Jane Nelsen) 出版社: 京华出版社 出版年: 2009-1 评语：挺精彩。以阿德勒理论为基础","text":"父母效能训练手册 9.1 (583人评价) 作者: 戈登 出版社: 天津社会科学院出版社 出版年: 2009-6-1 评语：即P.E.T，经典的亲子沟通图书。系统解决亲子沟通协商的难题。 正面管教 8.8 (1607人评价) 作者: [美] 简·尼尔森 (Jane Nelsen) 出版社: 京华出版社 出版年: 2009-1 评语：挺精彩。以阿德勒理论为基础 培养高情商的孩子 8.5 (243人评价) 作者: 约翰 戈特曼 出版社: 浙江人民出版社 出版年: 2014-2-1 评语：戈特曼的经典作品。原书英文名可译为：教养之道——培养高情商的孩子 无条件养育 8.6 (408人评价) 作者: 艾尔菲·科恩 出版社: 天津教育出版社 出版年: 2012-6 评语：很精彩，以自我决定论为理论基础。注重在育儿中培养孩子的内在动机。我认为这本书代表了教养未来的发展方向。不过操作性略有不足。本书译文读起来不够流畅，引用心理学实验较多，家长阅读可能稍有困难。 看见成长的自己 8.0 (613人评价) 作者: 卡罗尔·徳韦克 出版社: 中信出版社 出版年: 2011-6 评语：虽然这本书只有一章谈育儿。但德维克介绍了一种非常重要的成长型思维模式growth mindset。对成人和儿童发展都极具指导性。为什么要鼓励不要表扬，儿童做事遇挫时家长该如何鼓励？如何培养孩子的抗挫力和坚韧性（grit）？在本书都能获得很大启发。 加州大学伯克利分校的10堂幸福教养课 8.8 (13人评价) 作者: 克莉斯汀·卡特 出版社: 中国青年出版社 出版年: 2012-1 评语：国外著名高校的积极教养幸福课。将积极心理学应用于教养中 如何培养孩子的社会能力 8.1 (180人评价) 作者: 默娜·R.舒尔 出版社: 京华 出版年: 2009-8 评语：“我能解决同伴间的冲突” i can problem solve.适用于3-7岁。“解决同伴间的问题和解决数学题一样重要”。 全脑教养法 8.5 (310人评价) 作者: 丹尼尔·西格尔 出版社: 浙江人民出版社 出版年: 2013-4 评语：非常好读，简明清晰却不失深刻的脑科学与教养读本 游戏力 8.6 (735人评价) 作者: Lawrence J. Cohen, Ph.D. 出版社: 军事谊文出版社 出版年: 2011-5-1 评语：游戏疗法在教养中的应用，弥补了一般教养过于“正儿八经”的“缺憾”。 第56号教室的奇迹 8.6 (1430人评价) 作者: 雷夫•艾斯奎斯（Rafe Espuith） 出版社: 中国城市出版社 出版年: 2009 评语：全美最佳老师的分享，充满教育智慧。适用于小学年龄。 如何说孩子才会听，怎么听孩子才肯说 8.9 (2392人评价) 作者: [美]阿黛尔•法伯 伊莱恩•玛兹丽施 出版社: 中央编译出版社 出版年: 2007-11 评语：网上交口赞誉，很好读的亲子沟通读本。 如何说孩子才肯学 8.5 (264人评价) 作者: 阿黛尔·法伯 / 伊莱恩·玛兹丽施 出版社: 中央编译出版社 出版年: 2008.4 评语：与“如何说孩子才会听”同一作者 如何说孩子才能和平相处 8.9 (48人评价) 作者: [美] 阿黛尔·法伯 / [美] 伊莱恩·玛兹丽施 著 / [美] 肯伯利·安·蔻 插图 出版社: 中国商业出版社 出版年: 2010-1 评语：如何应对兄弟姐妹间和同伴冲突 如何说青少年才会听，怎么听青少年才肯说 8.3 (18人评价) 作者: 阿黛尔•法伯 / 伊莱恩•玛兹丽施 出版社: 高等教育出版社 出版年: 2008-11 评语：如何与青少年沟通 幸福的婚姻 8.5 (490人评价) 作者: [美] 约翰·戈特曼 / [美] 娜恩·西尔弗 出版社: 浙江人民出版社 出版年: 2014-2 评语：家庭和睦是教养的后院。后院起火，什么教养理念和方法都谈不上了。本书着力于如何改善夫妻关系，改善家庭生态，为戈特曼名作。自然，夫妻间的相处之道也是孩子人际学习的模版。 从出生到3岁 8.6 (404人评价) 作者: [美]伯顿·L·怀特（(Burton L.White） 出版社: 京华出版社 出版年: 2007-2 评语：陈忻博士推荐。经典图书，她推荐为0-3岁的首选 孩子，把你的手给我 8.8 (1290人评价) 作者: [美] 海姆·G.吉诺特 出版社: 京华出版社 出版年: 2004-9 评语：吉诺特著作。吉诺特作为先行者和倡导者，他的洞察，给很多后来者以很深的启发。 成为优秀父母的十大法则 8.0 (10人评价) 作者: 劳伦斯·斯坦伯格 出版社: 北京大学出版社 出版年: 2006-4 评语：通用法则类，非常好。作者曾任美国青少年心理协会会长，专注于青少年心理。 孩子，你的情绪我在乎 8.3 (27人评价) 作者: 约翰•戈特曼 出版社: 沈阳出版社 出版年: 2011-10 评语：这本书是韩国人写的，用的是戈特曼的理论。应该说情境很东亚，写的也挺好读。不过“干货”只有那么多，文字也不够简练（有点水分）。 管教有方 8.7 (21人评价) 作者: 简·尼尔森 出版社: 天津社科院 出版年: 2010-8 评语：为正面管教的同一作者，适合孩子为3-7岁的家长。以阿德勒理论为基础。 有话慢慢说 (1人评价) 作者: 汉恩·吉诺特 出版年: 2009-1 评语：吉诺特著作，与青少年沟通 关键教养报告 8.2 (69人评价) 作者: 波•布朗森 (Po Bronson) / 阿什利•梅里曼 (Ashley Merryman) 出版社: 浙江人民出版社 出版年: 2013-7-1 评语：介绍了很多当代心理学研究成果对教养的启发，很好读，不过个别章节为追求戏剧性稍有夸张。 让孩子的大脑自由 8.7 (439人评价) 作者: （美）约翰•梅迪纳 出版社: 浙江人民出版社 出版年: 2012-6 评语：介绍了不少新研究，有些类似《关键教养报告》 意志力 8.1 (2870人评价) 作者: [美] 罗伊·鲍迈斯特 / [美] 约翰·蒂尔尼 出版社: 中信出版社 出版年: 2012-6 评语：虽然并非教养读物，但关于意志力/自控力的规律是一样的。家长了解意志力，有助于提升自己和儿童的意志力。本书只有一章讲在育儿中如何提高孩子的意志力。 自控力 8.3 (24987人评价) 作者: [美] 凯利·麦格尼格尔 出版社: 文化发展出版社(原印刷工业出版社) 出版年: 2012-8 评语：虽然并非教养读物，但关于意志力/自控力的规律是一样的。家长了解意志力，有助于提升自己和儿童的意志力。本书没有专门章节谈在育儿中如何提高孩子的意志力。 教出乐观的孩子 8.3 (276人评价) 作者: 【美】马丁•塞利格曼 出版社: 万卷出版公司 出版年: 20100920 评语：如题，作者是乐观的著名研究者 安静 8.1 (1497人评价) 作者: 苏珊•凯恩 出版社: 中信出版社 出版年: 2012-9-1 评语：虽然并非教养读物，但有助于理解内向性格的来龙去脉。本书只有部分章节谈育儿中如何引导内向孩子 快乐交朋友 (1人评价) 作者: 米歇尔·波巴 出版社: 华东师大 出版年: 2011-5 评语：儿童在同伴关系遇到问题，不同情境下该怎么办。参考图书 打造儿童阅读环境 8.4 (87人评价) 作者: 艾登·钱伯斯 出版社: 南海出版公司 出版年: 2007-10 评语：如题，如何营造儿童良好的阅读环境+如何引导孩子爱上阅读，精彩，有指导性。 婴儿、儿童和青少年 9.1 (43人评价) 作者: [美]劳拉·E.贝克 出版社: 上海人民 出版年: 2008-11 评语：陈忻博士推荐，很有影响的儿童心理学教材。 故事知道怎么办 8.4 (233人评价) 作者: (澳大利亚)苏珊·佩罗 出版社: 天津教育出版社 出版年: 2011-8 评语：如何用故事帮助孩子成长和改变 解放父母解放孩子 8.9 (86人评价) 作者: [美] 阿黛尔•法伯和伊莱恩•玛兹丽施 著 出版社: 中国长安出版社 出版年: 2011-8","categories":[{"name":"教育","slug":"教育","permalink":"https://dxsm.github.io/categories/%E6%95%99%E8%82%B2/"}],"tags":[{"name":"儿童教育","slug":"儿童教育","permalink":"https://dxsm.github.io/tags/%E5%84%BF%E7%AB%A5%E6%95%99%E8%82%B2/"},{"name":"书籍","slug":"书籍","permalink":"https://dxsm.github.io/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"markdown参考案例","slug":"markdown_ref_nc","date":"2018-09-22T14:50:00.000Z","updated":"2022-04-02T14:53:23.000Z","comments":true,"path":"p/markdown-ref-nc.html","link":"","permalink":"https://dxsm.github.io/p/markdown-ref-nc.html","excerpt":"字符效果和横线等 删除线 斜体字 斜体字 粗体 粗体 粗斜体 粗斜体 高亮 波浪线 上标：X2 下标：O2 脚注 Content [1]","text":"字符效果和横线等 删除线 斜体字 斜体字 粗体 粗体 粗斜体 粗斜体 高亮 波浪线 上标：X2 下标：O2 脚注 Content [1] 缩写(同HTML的abbr标签) The HTML specification is maintained by the W3C. 引用 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 苹果 香蕉 锚点与链接 Links 普通链接 普通链接带标题 直接链接：https://github.com 锚点链接 mailto:test.test@gmail.com GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com 多语言代码高亮 Codes 行内代码 Inline code 执行命令：npm install marked 缩进风格 即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt; 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码 function test() { console.log(\"Hello world!\"); } (function(){ var box = function() { return box.fn.init(); }; box.prototype = box.fn = { init : function(){ console.log('box.init()'); return this; }, add : function(str) { alert(\"add\", str); return this; }, remove : function(str) { alert(\"remove\", str); return this; } }; box.fn.init.prototype = box.fn; window.box =box; })(); var testBox = box(); testBox.add(\"jQuery\").remove(\"jQuery\"); 图片 Images 列表 Lists 无序列表（加号和嵌套）Unordered Lists (+/-/*) 列表1 列表2 列表二-1 列表二-2 列表二-3 level 3 list 列表3 列表一 列表二 有序列表 Ordered Lists (1./2.) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 特殊符号 HTML Entities Codes © &amp; ¨ ™ ¡ £ &amp; &lt; &gt; ¥ € ® ± ¶ § ¦ ¯ « · X² Y³ ¾ ¼ × ÷ » 18ºC &quot; ' Emoji表情 😃 😃 😂 @mentions, ⭐️ #refs, links, formatting, and tags supported 💘; list syntax required (any unordered or ordered list supported) ⏰; ♥️ 💛 💝 this is a complete item 👍 👎; this is an incomplete item test link 💊 💉 @pandao 📜 📁 📂; ⚙️ this is an incomplete item 🔍 🔒 ✉️ 📌 📎 📝 📆 📅 ; ⚡️ this is an incomplete item test link 🎉 🔔 ⏳; 🐰 ❓ ❗️ 🔖 📚 🔥 this is 🎶 ☀️ 🍄 an incomplete item test link; 🍵 🍎 🏠 🇨🇳 ▶️ ☑️ 🔗 :fa-gear: :fa-gear: ⚡️ 科学公式 TeX(KaTeX) E=mc2E=mc^2 E=mc2 行内的公式E=mc2E=mc^2E=mc2行内的公式，行内的E=mc2E=mc^2E=mc2公式。 x&gt;yx &gt; y x&gt;y (3x−1+(1+x)2)(\\sqrt{3x-1}+(1+x)^2) (3x−1​+(1+x)2) sin⁡(α)θ=∑i=0n(xi+cos⁡(f))\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f)) sin(α)θ=i=0∑n​(xi+cos(f)) 拓展功能–自定义div detail折叠 Python code import os print(\"hello world\") hint块 hello world hello world hello world hello world pannel块 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 绘制流程图 Flowchart 流程图语法参考 https://github.com/adrai/flowchart.js Markdown常用的元素有以下几种： start end operation condition inputoutput subroutine st=&gt;start: Start:&gt;https://dxsm.github.io[blank] e=&gt;end:&gt;https://dxsm.github.io op1=&gt;operation: My Operation sub1=&gt;subroutine: My Subroutine cond=&gt;condition: Yes or No?:&gt;https://dxsm.github.io io=&gt;inputoutput: catch something... para=&gt;parallel: parallel tasks st-&gt;op1-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;para para(path1, bottom)-&gt;sub1(right)-&gt;op1 para(path2, top)-&gt;op1 状态标记 Markdown会使用不同的颜色来标记状态，状态主要有以下几种： past current future approved rejected invalid start=&gt;start: 开始|past requirementAnalysis=&gt;operation: 需求分析|past design=&gt;operation: 软件设计|past coding=&gt;operation: 编码|past selfTestingPased=&gt;condition: 自测通过？|approved debug=&gt;operation: debug|invalid submitTestingPased=&gt;condition: 提测通过？|rejected modifyBug=&gt;operation: 修bug|current deploy=&gt;operation: 部署|future end=&gt;end: 结束|future start-&gt;requirementAnalysis-&gt;design-&gt;coding-&gt;selfTestingPased selfTestingPased(no)-&gt;debug(right)-&gt;selfTestingPased selfTestingPased(yes)-&gt;submitTestingPased submitTestingPased(yes)-&gt;deploy-&gt;end submitTestingPased(no)-&gt;modifyBug(right)-&gt;submitTestingPased Sequence Diagram 语法参考 https://bramp.github.io/js-sequence-diagrams/ Andrew-&gt;China: Says Hello Note right of China: China thinks\\nabout it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! mermaid mermaid非常强大，基本能够替代上面两种流程图，语法参考 https://mermaid-js.github.io/mermaid/#/flowchart sequence diagram sequenceDiagram Alice -&gt;&gt; Bob: Hello Bob, how are you? Bob--&gt;&gt;John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row. Bob--&gt;Alice: Checking with John... Alice-&gt;John: Yes... John, how are you? flowchart graph LR A[Square Rect] -- Link text --&gt; B((Circle)) A --&gt; C(Round Rect) B --&gt; D{Rhombus} C --&gt; D state diagram stateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] pie chart pie title Pets adopted by volunteers &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 15 gantt gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d 电路时序图 clkdatheadbodytaildatareqack 思维导图 height: 200px #主题 ##论点1 ###概述1 ###概述2 ##论点2 ##论点3 ##论点4 我是脚注 ↩︎","categories":[{"name":"markdown","slug":"markdown","permalink":"https://dxsm.github.io/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://dxsm.github.io/tags/markdown/"}]}],"categories":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/categories/SpinalHDL/"},{"name":"linux","slug":"linux","permalink":"https://dxsm.github.io/categories/linux/"},{"name":"markdown","slug":"markdown","permalink":"https://dxsm.github.io/categories/markdown/"},{"name":"typora","slug":"typora","permalink":"https://dxsm.github.io/categories/typora/"},{"name":"低功耗设计","slug":"低功耗设计","permalink":"https://dxsm.github.io/categories/%E4%BD%8E%E5%8A%9F%E8%80%97%E8%AE%BE%E8%AE%A1/"},{"name":"electron","slug":"electron","permalink":"https://dxsm.github.io/categories/electron/"},{"name":"ASIC测试","slug":"ASIC测试","permalink":"https://dxsm.github.io/categories/ASIC%E6%B5%8B%E8%AF%95/"},{"name":"SOC设计","slug":"SOC设计","permalink":"https://dxsm.github.io/categories/SOC%E8%AE%BE%E8%AE%A1/"},{"name":"ASIC设计","slug":"ASIC设计","permalink":"https://dxsm.github.io/categories/ASIC%E8%AE%BE%E8%AE%A1/"},{"name":"Python","slug":"Python","permalink":"https://dxsm.github.io/categories/Python/"},{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/categories/eda-tools/"},{"name":"git","slug":"git","permalink":"https://dxsm.github.io/categories/git/"},{"name":"vim","slug":"vim","permalink":"https://dxsm.github.io/categories/vim/"},{"name":"UPF","slug":"UPF","permalink":"https://dxsm.github.io/categories/UPF/"},{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"},{"name":"Linux","slug":"Linux","permalink":"https://dxsm.github.io/categories/Linux/"},{"name":"教育","slug":"教育","permalink":"https://dxsm.github.io/categories/%E6%95%99%E8%82%B2/"}],"tags":[{"name":"SpinalHDL","slug":"SpinalHDL","permalink":"https://dxsm.github.io/tags/SpinalHDL/"},{"name":"linux","slug":"linux","permalink":"https://dxsm.github.io/tags/linux/"},{"name":"markdown","slug":"markdown","permalink":"https://dxsm.github.io/tags/markdown/"},{"name":"typora","slug":"typora","permalink":"https://dxsm.github.io/tags/typora/"},{"name":"Low Power","slug":"Low-Power","permalink":"https://dxsm.github.io/tags/Low-Power/"},{"name":"electron","slug":"electron","permalink":"https://dxsm.github.io/tags/electron/"},{"name":"electron-vue","slug":"electron-vue","permalink":"https://dxsm.github.io/tags/electron-vue/"},{"name":"jtag","slug":"jtag","permalink":"https://dxsm.github.io/tags/jtag/"},{"name":"AMBA","slug":"AMBA","permalink":"https://dxsm.github.io/tags/AMBA/"},{"name":"SOC","slug":"SOC","permalink":"https://dxsm.github.io/tags/SOC/"},{"name":"AXI","slug":"AXI","permalink":"https://dxsm.github.io/tags/AXI/"},{"name":"设计技巧","slug":"设计技巧","permalink":"https://dxsm.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7/"},{"name":"资源优化","slug":"资源优化","permalink":"https://dxsm.github.io/tags/%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/"},{"name":"流保序","slug":"流保序","permalink":"https://dxsm.github.io/tags/%E6%B5%81%E4%BF%9D%E5%BA%8F/"},{"name":"Python","slug":"Python","permalink":"https://dxsm.github.io/tags/Python/"},{"name":"正则","slug":"正则","permalink":"https://dxsm.github.io/tags/%E6%AD%A3%E5%88%99/"},{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"fifo","slug":"fifo","permalink":"https://dxsm.github.io/tags/fifo/"},{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/tags/eda-tools/"},{"name":"git","slug":"git","permalink":"https://dxsm.github.io/tags/git/"},{"name":"vim","slug":"vim","permalink":"https://dxsm.github.io/tags/vim/"},{"name":"vimrc","slug":"vimrc","permalink":"https://dxsm.github.io/tags/vimrc/"},{"name":"UPF","slug":"UPF","permalink":"https://dxsm.github.io/tags/UPF/"},{"name":"AHB","slug":"AHB","permalink":"https://dxsm.github.io/tags/AHB/"},{"name":"testbench","slug":"testbench","permalink":"https://dxsm.github.io/tags/testbench/"},{"name":"systemverilog","slug":"systemverilog","permalink":"https://dxsm.github.io/tags/systemverilog/"},{"name":"面试","slug":"面试","permalink":"https://dxsm.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Linux","slug":"Linux","permalink":"https://dxsm.github.io/tags/Linux/"},{"name":"儿童教育","slug":"儿童教育","permalink":"https://dxsm.github.io/tags/%E5%84%BF%E7%AB%A5%E6%95%99%E8%82%B2/"},{"name":"书籍","slug":"书籍","permalink":"https://dxsm.github.io/tags/%E4%B9%A6%E7%B1%8D/"}]}