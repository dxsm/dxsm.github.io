{"meta":{"title":"Dylan","subtitle":null,"description":"本博客专注于ASIC数字电路相关知识,提供优质的技术文章","author":"董续胜","url":"https://dxsm.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-08-10T08:41:10.000Z","updated":"2020-04-09T16:13:13.953Z","comments":true,"path":"about/index.html","permalink":"https://dxsm.github.io/about/index.html","excerpt":"","text":"教育经历 硕士 电路与系统专业 电子科技大学 联系方式 电子邮箱 959229640@qq.com 地址 上海浦东新区 QQ 959229640"},{"title":"留言版","date":"2019-08-05T09:17:02.000Z","updated":"2020-04-06T08:29:17.860Z","comments":true,"path":"contact/index.html","permalink":"https://dxsm.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 博客名称: Dylan 博客网址: https://dxsm.github.io 博客头像: https://cdn.jsdelivr.net/gh/dxsm/cdn/images/avatar3.jpg 博客介绍: 专注于ASIC设计，Python经验分享"},{"title":"友情链接","date":"2019-02-13T12:25:59.000Z","updated":"2020-03-30T14:32:56.777Z","comments":false,"path":"links/index.html","permalink":"https://dxsm.github.io/links/index.html","excerpt":"","text":""},{"title":"相册","date":"2020-02-22T07:34:31.009Z","updated":"2020-02-22T07:34:31.009Z","comments":true,"path":"galleries/index.html","permalink":"https://dxsm.github.io/galleries/index.html","excerpt":"","text":""},{"title":"在线小游戏","date":"2019-02-13T12:25:59.000Z","updated":"2020-04-09T15:25:14.803Z","comments":false,"path":"games/index.html","permalink":"https://dxsm.github.io/games/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-08-10T08:39:20.000Z","updated":"2020-02-22T07:34:31.009Z","comments":true,"path":"archives/index.html","permalink":"https://dxsm.github.io/archives/index.html","excerpt":"","text":""},{"title":"在线工具","date":"2019-02-13T12:25:59.000Z","updated":"2020-04-09T16:05:08.272Z","comments":false,"path":"tools/index.html","permalink":"https://dxsm.github.io/tools/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2018-10-22T08:10:46.000Z","updated":"2020-03-08T07:53:05.157Z","comments":false,"path":"categories/index.html","permalink":"https://dxsm.github.io/categories/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2018-10-22T08:11:42.000Z","updated":"2020-03-08T07:52:18.363Z","comments":false,"path":"tags/index.html","permalink":"https://dxsm.github.io/tags/index.html","excerpt":"","text":""},{"title":"背景图片4","date":"2020-02-22T07:34:31.010Z","updated":"2020-02-22T07:34:31.010Z","comments":true,"path":"galleries/背景图片4/index.html","permalink":"https://dxsm.github.io/galleries/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%874/index.html","excerpt":"","text":""},{"title":"背景图片3","date":"2020-02-22T07:34:31.010Z","updated":"2020-02-22T07:34:31.010Z","comments":true,"path":"galleries/背景图片3/index.html","permalink":"https://dxsm.github.io/galleries/%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%873/index.html","excerpt":"","text":""}],"posts":[{"title":"Python正则表达式","slug":"python_regular_expression","date":"2019-08-24T08:30:02.000Z","updated":"2020-03-07T09:08:15.974Z","comments":true,"path":"p/python-regular-expression.html","link":"","permalink":"https://dxsm.github.io/p/python-regular-expression.html","excerpt":"1. 为什么使用正则表达式？ 典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 通过使用正则表达式，可以： 测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。","text":"1. 为什么使用正则表达式？ 典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 通过使用正则表达式，可以： 测试字符串内的模式。 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。 替换文本。 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。 基于模式匹配从字符串中提取子字符串。 可以查找文档内或输入域内特定的文本。 2. 匹配规则 3. re模块常用函数 3.1 re.match函数 re.match尝试从字符串的起始位置匹配一个模式，匹配成功则返回match对象；如果不是起始位置匹配成功的话，match()就返回none。 函数语法： re.match(pattern, string[, flags=0]) 函数参数说明： pattern：匹配的正则表达式 string：要匹配的字符串。 flags：标志位，用于控制正则表达式的匹配方式，取值可以使用按位或运算符’|'表示同时生效 re.I(re.IGNORECASE)：忽略大小写 re.M(re.MULTILINE)：多行匹配，改变’^‘和’$'的行为 re.S(re.DOTALL)：改变’.‘的行为，使’.'匹配包括换行在内的所有字符 re.L(re.LOCALE)：做本地化识别（locale-aware）匹配，使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 re.U(re.UNICODE)：根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X(re.VERBOSE)： 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 3.1.1 返回值match对象 Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。 属性： string: 匹配时使用的文本。 re: 匹配时使用的Pattern对象。 pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.search()方法的同名参数相同。 endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.search()方法的同名参数相同。 lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。 lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。 方法： group([group1, …]): 获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 span([group]): 返回(start(group), end(group))。 expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，而不是分组10，只能使用\\g&lt;1&gt;0。 3.1.2 实例 #!/usr/bin/env python import re str1 = \"\"\"baidu.com www.google.com www.12306.cn\"\"\" str2 = \"\"\"www.baidu.com www.google.com www.12306.cn\"\"\" pattern = r\"(\\w+)\\.(\\w+)\\.(?P&lt;domain>\\w+)\" match = re.match(pattern, str1) print(match) #None match = re.match(pattern, str2) print(match) #&lt;_sre.SRE_Match object; span=(0, 13), match='www.baidu.com'> if match: print(match.pos) #0 print(match.endpos) #41 print(match.group()) #www.baidu.com print(match.group(2)) #baidu print(match.group(2,3)) #('baidu', 'com') print(match.groups()) #('www', 'baidu', 'com') print(match.groupdict()) #{'domain': 'com'} print(match.span()) #(0, 13) print(match.span(3)) #(10, 13) print(match.start(3)) #10 print(match.expand(r\"\\3 \\1 \\2 \\g&lt;domain>\")) #com www baidu com else: print(\"No match!!!\") 3.2 re.search函数 re.search扫描整个字符串并返回第一个成功的匹配。 函数语法： re.search(pattern, string[, flags=0]) 实例 #!/usr/bin/env python import re str1 = \"\"\"baidu.com www.google.com www.12306.cn\"\"\" str2 = \"\"\"www.baidu.com www.google.com www.12306.cn\"\"\" pattern = r\"(\\w+)\\.(\\w+)\\.(?P&lt;domain>\\w+)\" match = re.search(pattern, str1) print(match) #&lt;_sre.SRE_Match object; span=(10, 24), match='www.google.com'> match = re.search(pattern, str2) print(match) #&lt;_sre.SRE_Match object; span=(0, 13), match='www.baidu.com'> 3.3 re.findall函数 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 函数语法： re.findall(pattern, string[, flags=0]) 实例 #!/usr/bin/env python import re text = \"\"\"www.baidu.com Site: www.google.com www.12306.cn\"\"\" pattern = r\"(\\w+)\\.(\\w+)\\.(\\w+)\" match = re.findall(pattern, text, re.M) print(match) #[('www', 'baidu', 'com'), ('www', 'google', 'com'), ('www', '12306', 'cn')] 3.4 re.finditer函数 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器 函数语法： re.finditer(pattern, string[, flags=0]) 实例 #!/usr/bin/env python import re for m in re.finditer(r\"\\d+\",'one1two2three3four4'): print(m.group(), end=\" \") #1 2 3 4 3.5 re.sub函数 使用repl替换string中每一个匹配的子串后返回替换后的字符串。 当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。 当repl是一个函数时，这个函数应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 count用于指定最多替换次数，不指定时全部替换。 函数语法： re.sub(pattern, repl, string[, count]) 实例 #!/usr/bin/env python import re text = 'i say, hello world!' pattern = r'(\\w+) (\\w+)' print(re.sub(pattern, r'\\2 \\1', text)) #say i, world hello! def func(m): return m.group(1).title() + ' ' + m.group(2).title() print(re.sub(pattern, func, text)) #I Say, Hello World! print(re.sub(pattern, func, text, 1)) #I Say, hello world! 3.6 re.subn函数 返回 (sub(repl, string[, count]), 替换次数)。 函数语法： re.subn(pattern, repl, string[, count]) 实例 #!/usr/bin/env python import re text = 'i say, hello world!' pattern = r'(\\w+) (\\w+)' print(re.sub(pattern, r'\\2 \\1', text)) #('say i, world hello!', 2) def func(m): return m.group(1).title() + ' ' + m.group(2).title() print(re.sub(pattern, func, text)) #('I Say, Hello World!', 2) print(re.sub(pattern, func, text, 1)) #('I Say, hello world!', 1) 3.7 re.split函数 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 函数语法： re.split(pattern, string[, maxsplit]): 实例 #!/usr/bin/env python import re text = 'one1two2three3four4' pattern = r\"\\d+\" print(re.split(pattern, text)) #['one', 'two', 'three', 'four', ''] print(re.split(pattern, text, 2)) #['one', 'two', 'three3four4'] 4. Pattern对象 re.compile函数构造： re.compile(strPattern[, flag]) 方法： match(string[, pos[, endpos]])：功能等同于re.match函数。不同的是可以指定匹配的起始与终止下标，pos和endpos的默认值分别为0和len(string)，re.match()无法指定这两个参数。 search(string[, pos[, endpos]])：同上 findall(string[, pos[, endpos]])：同上 finditer(string[, pos[, endpos]])：同上 sub(repl, string[, count]) subn(repl, string[, count]) split(string[, maxsplit]) 实例 #!/usr/bin/env python import re s = \"Steven is 17 years old.\" p = re.compile(r\"\\d+\") print(p.match(s)) #None print(p.match(s,10)) #&lt;_sre.SRE_Match object; span=(10, 12), match='17'> 5. 匹配方式–flags 5.1 re.M 实例：替换多行的行首note为warning #!/usr/bin/env python import re text = \"\"\"note: Meeting will begin at 8:00. note: Please take your notebook. note: Meeting will end at 10:00. (note: turn off the light) \"\"\" p = re.compile(r\"^note\") print((p.sub(\"warning\",text))) #only the first line has substitute p = re.compile(r\"^note\", re.M) print((p.sub(\"warning\",text))) #sub all line 5.2 re.S 改变’.'符号的行为，使其能够匹配换行符 #!/usr/bin/env python import re text = \"\"\" parameter MODE = 1 , DIN_WIDTH = 32, DOUT_WIDTH = 24; \"\"\" p = re.compile(r\"parameter(.*);\") m = p.search(text) print(m) #None p = re.compile(r\"parameter\\s+(.*);\", re.S) m = p.search(text) print(m.group(1)) 6. 贪婪模式 Python里数量词默认是贪婪的，总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式&quot;ab*“如果用于查找&quot;abbbc”，将找到&quot;abbb&quot;。而如果使用非贪婪的数量词&quot;ab*?&quot;，将找到&quot;a&quot;。 #!/usr/bin/env python import re text = \"abcaxc\" m = re.match(r\"ab.*c\",text) print(m.group()) #abcaxc m = re.match(r\"ab.*?c\",text) print(m.group()) #abc","categories":[{"name":"Python","slug":"Python","permalink":"https://dxsm.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dxsm.github.io/tags/Python/"},{"name":"正则","slug":"正则","permalink":"https://dxsm.github.io/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"异步FIFO设计","slug":"fifo_design","date":"2019-05-04T15:30:02.000Z","updated":"2020-03-08T07:27:52.263Z","comments":true,"path":"p/fifo-design.html","link":"","permalink":"https://dxsm.github.io/p/fifo-design.html","excerpt":"","text":"1. 异步fifo代码 module afifo #(parameter DATA_WIDTH = 64, FIFO_DEPTH = 8, AF_LEVEL = (1&lt;&lt;FIFO_DEPTH - 10), AE_LEVEL = 10 ) ( input wclk , input wrst , input wen , input [DATA_WIDTH-1:0] wdata , output reg wfull , output reg walmost_full , input rclk , input rrst , input ren , output reg [DATA_WIDTH-1:0] rdata , output reg rempty , output reg ralmost_empty ); wire fifo_rd; wire fifo_wr; wire [FIFO_DEPTH-1:0] raddr; wire [FIFO_DEPTH-1:0] waddr; reg [DATA_WIDTH-1:0] memory [0:(1&lt;&lt;FIFO_DEPTH)-1]; wire wen_mask; wire [FIFO_DEPTH:0] wbinnext; wire [FIFO_DEPTH:0] wptrnext; reg [FIFO_DEPTH:0] wbin; reg [FIFO_DEPTH:0] wptr; reg [FIFO_DEPTH:0] wptr_rsync1; reg [FIFO_DEPTH:0] wptr_rsync2; wire [FIFO_DEPTH:0] wbin_rsync; wire ren_mask; wire [FIFO_DEPTH:0] rbinnext; wire [FIFO_DEPTH:0] rptrnext; reg [FIFO_DEPTH:0] rbin; reg [FIFO_DEPTH:0] rptr; reg [FIFO_DEPTH:0] rptr_wsync1; reg [FIFO_DEPTH:0] rptr_wsync2; wire [FIFO_DEPTH:0] rbin_wsync; genvar i; //************************************* // Dual port RAM //************************************* assign fifo_wr = wen_mask; always @(posedge wclk) begin if(fifo_wr) memory[waddr] &lt;= wdata; end assign fifo_rd = ren_mask; always @(posedge rclk) begin if(fifo_rd) rdata &lt;= memory[raddr]; end // //************************************* // sync wptr to rclk domain //************************************* always @(posedge rclk or negedge rrst) begin if(rrst) {wptr_rsync2,wptr_rsync1} &lt;= 0; else {wptr_rsync2,wptr_rsync1} &lt;= {wptr_rsync1,wptr}; end generate for(i=FIFO_DEPTH;i>=0;i=i-1) begin: wbin_rsync_gen assign wbin_rsync[i] = ^({ {i{1'b0}},wptr_rsync2[FIFO_DEPTH:i]}); end endgenerate //************************************* // sync rptr to wclk domain //************************************* always @(posedge wclk or negedge wrst) begin if(wrst) {rptr_wsync2,rptr_wsync1} &lt;= 0; else {rptr_wsync2,rptr_wsync1} &lt;= {rptr_wsync1,rptr}; end generate for(i=FIFO_DEPTH;i>=0;i=i-1) begin: rbin_wsync_gen assign rbin_wsync[i] = ^({ {i{1'b0}},rptr_wsync2[FIFO_DEPTH:i]}); end endgenerate //************************************* // rd addr generate //************************************* always @(posedge rclk or negedge rrst) begin if(rrst) {rbin,rptr} &lt;= 0; else {rbin,rptr} &lt;= {rbinnext,rptrnext}; end assign raddr = rbin[FIFO_DEPTH-1:0]; assign ren_mask = ren &amp; (~rempty); assign rbinnext = ren_mask ? (rbin + 1'b1) : rbin; assign rptrnext = (rbinnext>>1) ^ rbinnext; //************************************* // wr addr generate //************************************* always @(posedge wclk or negedge wrst) begin if(wrst) {wbin,wptr} &lt;= 0; else {wbin,wptr} &lt;= {wbinnext,wptrnext}; end assign waddr = wbin[FIFO_DEPTH-1:0]; assign wen_mask = (wen &amp; (~wfull)); assign wbinnext = wen_mask ? (wbin + 1'b1) : wbin; assign wptrnext = (wbinnext>>1) ^ wbinnext; //************************************* // FIFO status //************************************* always @(posedge rclk or negedge rrst) begin if(rrst) rempty &lt;= 1'b1; else rempty &lt;= (rptrnext == wptr_rsync2); end always @(posedge rclk or negedge rrst) begin if(rrst) ralmost_empty &lt;= 1'b1; else ralmost_empty &lt;= (wbin_rsync - rbinnext &lt;= AE_LEVEL); end always @(posedge wclk or negedge wrst) begin if(wrst) wfull &lt;= 0; else wfull &lt;= (wptrnext == {~rptr_wsync2[FIFO_DEPTH:FIFO_DEPTH-1],rptr_wsync2[FIFO_DEPTH-2:0]}); end always @(posedge wclk or negedge wrst) begin if(wrst) walmost_full &lt;= 1'b1; else walmost_full &lt;= (wbinnext - rbin_wsync >= AF_LEVEL); end endmodule","categories":[{"name":"ASIC设计","slug":"ASIC设计","permalink":"https://dxsm.github.io/categories/ASIC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"fifo","slug":"fifo","permalink":"https://dxsm.github.io/tags/fifo/"}]},{"title":"搭建irun编译与起verdi小环境","slug":"compile_env","date":"2019-05-04T14:30:02.000Z","updated":"2020-03-07T09:08:15.966Z","comments":true,"path":"p/compile-env.html","link":"","permalink":"https://dxsm.github.io/p/compile-env.html","excerpt":"1. 小环境makefile模板 design = tb verilog_flist = -f ./test.vc tb.v vhd_flist = wave = wave.fsdb #whether to open verdi wave gui ifdef wave verdi_cmd += -ssf $(wave) endif .PHONY: help clean ius compile verdi help: @echo \"#===============================================================\" @echo \"# [Info] make help : show help infomation\" @echo \"# [Info] make clean : clean ius and verdi compile library,log\" @echo \"# [Info] make compile : compile for verdi\" @echo \"# [Info] make verdi : raise verdi gui\" @echo \"#===============================================================\" clean: @rm chip_lib.lib++ work.lib++ INCA_libs verdiLog vericomLog vhdlcomLog -rf ius: irun +access+wr -smartorder -clean -ntcnotchks -V93 -vtimescale 1ns/1ps +define+RD=1 -work chip_lib $(verilog_flist) $(vhd_flist) -top $(design) -64bit compile: ifdef vhdl_flist vhdlcom -V93 -sup_sem_error -smartorder -work chip_lib $(vhdl_flist) endif ifdef verilog_flist vericom -sv +systemverilog+sv +v95ext+v95 +verilog2001ext+v -ignorekwd_config +define+RD=1 -work chip_lib $(verilog_flist) endif verdi:compile verdi -lib chip_lib $(verdi_cmd) &amp;","text":"1. 小环境makefile模板 design = tb verilog_flist = -f ./test.vc tb.v vhd_flist = wave = wave.fsdb #whether to open verdi wave gui ifdef wave verdi_cmd += -ssf $(wave) endif .PHONY: help clean ius compile verdi help: @echo \"#===============================================================\" @echo \"# [Info] make help : show help infomation\" @echo \"# [Info] make clean : clean ius and verdi compile library,log\" @echo \"# [Info] make compile : compile for verdi\" @echo \"# [Info] make verdi : raise verdi gui\" @echo \"#===============================================================\" clean: @rm chip_lib.lib++ work.lib++ INCA_libs verdiLog vericomLog vhdlcomLog -rf ius: irun +access+wr -smartorder -clean -ntcnotchks -V93 -vtimescale 1ns/1ps +define+RD=1 -work chip_lib $(verilog_flist) $(vhd_flist) -top $(design) -64bit compile: ifdef vhdl_flist vhdlcom -V93 -sup_sem_error -smartorder -work chip_lib $(vhdl_flist) endif ifdef verilog_flist vericom -sv +systemverilog+sv +v95ext+v95 +verilog2001ext+v -ignorekwd_config +define+RD=1 -work chip_lib $(verilog_flist) endif verdi:compile verdi -lib chip_lib $(verdi_cmd) &amp;","categories":[{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/categories/eda-tools/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/tags/eda-tools/"}]},{"title":"git配置与使用教程","slug":"git_learning","date":"2019-05-04T14:23:02.000Z","updated":"2020-03-07T09:08:15.970Z","comments":true,"path":"p/git-learning.html","link":"","permalink":"https://dxsm.github.io/p/git-learning.html","excerpt":"1. git配置 放在~/.gitconfig文件中 [user] name = victor.dong email = dxs_uestc@163.com [color] ui = auto [alias] st = status co = checkout ci = commit br = branch df = diff dfn = diff --name-only dfs = diff --staged dft = difftool dfts = difftool --staged mr = merge mrt = mergetool last = log -1 HEAD amend = commit -C HEAD -a --amend lg = log --color --graph --pretty=format:'%C(yellow)%h%C(reset) - %C()%cd%C(reset) %C()&lt;%an>%C(reset)%C(red)%d%C(reset) %C(ul)%s%C(reset)' --abbrev-commit --date=format:'%y/%m/%d %H:%M:%S' ls = log --name-only --color --graph --pretty=format:'%C(yellow)%h%C(reset) - %C()%cd%C(reset) %C()&lt;%an>%C(reset)%C(red)%d%C(reset) %C(ul)%s%C(reset)' --abbrev-commit --date=format:'%y/%m/%d %H:%M:%S' #not show log in new page [core] pager = #diff tool use beyond compare [diff] tool = bcomp [difftool \"bcomp\"] cmd = \\\"/usr/bin/bcompare\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" [difftool] prompt = false #merge tool use beyond compare [merge] tool = bcomp [mergetool \"bcomp\"] cmd = \\\"/usr/bin/bcompare\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" \\\"$MERGED\\\" [mergetool] prompt = false","text":"1. git配置 放在~/.gitconfig文件中 [user] name = victor.dong email = dxs_uestc@163.com [color] ui = auto [alias] st = status co = checkout ci = commit br = branch df = diff dfn = diff --name-only dfs = diff --staged dft = difftool dfts = difftool --staged mr = merge mrt = mergetool last = log -1 HEAD amend = commit -C HEAD -a --amend lg = log --color --graph --pretty=format:'%C(yellow)%h%C(reset) - %C()%cd%C(reset) %C()&lt;%an>%C(reset)%C(red)%d%C(reset) %C(ul)%s%C(reset)' --abbrev-commit --date=format:'%y/%m/%d %H:%M:%S' ls = log --name-only --color --graph --pretty=format:'%C(yellow)%h%C(reset) - %C()%cd%C(reset) %C()&lt;%an>%C(reset)%C(red)%d%C(reset) %C(ul)%s%C(reset)' --abbrev-commit --date=format:'%y/%m/%d %H:%M:%S' #not show log in new page [core] pager = #diff tool use beyond compare [diff] tool = bcomp [difftool \"bcomp\"] cmd = \\\"/usr/bin/bcompare\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" [difftool] prompt = false #merge tool use beyond compare [merge] tool = bcomp [mergetool \"bcomp\"] cmd = \\\"/usr/bin/bcompare\\\" \\\"$LOCAL\\\" \\\"$REMOTE\\\" \\\"$BASE\\\" \\\"$MERGED\\\" [mergetool] prompt = false","categories":[{"name":"git","slug":"git","permalink":"https://dxsm.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://dxsm.github.io/tags/git/"}]},{"title":"vim配置方案","slug":"vim_cfg","date":"2019-05-04T07:23:02.000Z","updated":"2020-03-07T09:08:15.980Z","comments":true,"path":"p/vim-cfg.html","link":"","permalink":"https://dxsm.github.io/p/vim-cfg.html","excerpt":"1. VIM插件及效果图 插件推荐： NERDTree: 树型目录 supertab: 自动补全，支持补全路径 UltiSnips: 补全代码神器 vim-snippets: 将UltiSnips文件夹拷贝到~/.vim 效果图：","text":"1. VIM插件及效果图 插件推荐： NERDTree: 树型目录 supertab: 自动补全，支持补全路径 UltiSnips: 补全代码神器 vim-snippets: 将UltiSnips文件夹拷贝到~/.vim 效果图： 2. VIM配置方案 将如下配置放在~/.vimrc文件下 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => General \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Sets how many lines of history VIM has to remember set history=500 \" display numbers set nu \"visual edit everywhere set virtualedit=all \"show command set showcmd set cmdheight=2 set scrolloff=3 \" Enable filetype plugins filetype plugin on filetype indent on \" Set to auto read when a file is changed from the outside set autoread set nocompatible \" Search set ignorecase \" Ignore case when searching set smartcase \" When searching try to be smart about cases set hlsearch \" Highlight search results set incsearch \" Makes search act like search in modern browsers \" Don't redraw while executing macros (good performance config) set lazyredraw \" For regular expressions turn magic on set magic \" Show matching brackets when text indicator is over them set showmatch \" How many tenths of a second to blink when matching brackets set mat=2 \" No annoying sound on errors set noerrorbells set novisualbell set t_vb= set tm=500 \" Add a bit extra margin to the left set foldcolumn=1 set fdm=marker \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => Colors and Fonts \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Enable syntax highlighting syntax enable colorscheme monokai \"colorscheme murphy \"colorscheme solarized \"let g:solarized_termcolors=256 \"let g:solarized_contrast=\"high\" \"default value is normal set t_Co=256 \"set vim terminal color set background=dark \"set guifont=Mono\\ 13 set guifont=monaco\\ 14 \" Set extra options when running in GUI mode if has(\"gui_running\") set guioptions+=m \"hide menu set guioptions-=T \"hide tool set guioptions-=L \"hide left scrollbar set guioptions-=r \"hide right scrollbar set guioptions-=b \"hide bottom scrollbar set guitablabel=%M\\ %t else \"hi Comment term=italic ctermfg=Darkgray \" colorscheme molokai endif \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => Statusline setting \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" set statusline=%1*\\ [%{Disp_Mode()}]\\ %*\\ %-5.58(%F%m%r%h%w%)\\ %2*\\ %-5.58(CWD:\\ %{getcwd()}%)\\ %*\\ Format:\\ [%{&amp;fenc!=''?&amp;fenc:&amp;enc}]\\ %3*\\ FileType:\\ %y\\ %*\\ %([L:\\ %l,C:\\ %c][%p%%]%)%&lt; hi User1 guibg=slateblue guifg=Gray ctermfg=Gray ctermbg=93 hi User2 guibg=#4876FF guifg=Gray ctermfg=Gray ctermbg=53 hi User3 guibg=Brown guifg=Gray ctermfg=Gray ctermbg=160 hi StatusLine guibg=#cccccc guifg=#222222 set laststatus=2 \"2:always display \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => file coding and decoding \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Set utf8 as standard encoding and en_US as the standard language set termencoding=utf-8 set encoding=utf8 set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,latin1 \"decoding list set fileencoding=utf-8 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => Files, backups and undo \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Turn backup off, since most stuff is in SVN, git et.c anyway... set nobackup set nowb set noswapfile \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" => Text, tab and indent related \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" 1 tab == 4 spaces set shiftwidth=4 set tabstop=4 set softtabstop=4 \" Use spaces instead of tabs set expandtab \" Be smart when using tabs set smarttab \"toggle paste mode with hitting F2 key set pastetoggle=&lt;F2> \"set paste \"open paste mode set ai \"Auto indent set si \"Smart indent \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Wrap and breakline setting \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" Linebreak on 500 characters set lbr \"linebreak set tw=500 \"break at 500 words set showbreak==>\\ \"show \"=>\" before the break line set wrap \"Wrap lines \"configure backspace set backspace=eol,start,indent set whichwrap+=&lt;,>,h,l \" Highlight the current line set cursorline \"highlight CursorLine guibg=#003853 ctermbg=24 gui=none cterm=none set clipboard=unnamed \"yank unnamed register to the system register \" Return to last edit position when opening files (You want this!) autocmd! BufReadPost * \\ if line(\"'\\\"\") > 0 &amp;&amp; line(\"'\\\"\") &lt;= line(\"$\") | \\ exe \"normal! g`\\\"\" | \\ endif \"auto load ~/.vimrc autocmd! BufWritePost $MYVIMRC source $MYVIMRC let mapleader = ',' let g:mapleader = ',' \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"save and quit \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"quit without save map &lt;leader>q :q!&lt;cr> \"save and quit map &lt;leader>w :wq!&lt;cr> \"save force with :W \"command! W w !sudo tee % > /dev/null \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"save and quit \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" map &lt;leader>tn :tabnew&lt;cr> map &lt;leader>tc :tabclose&lt;cr> map &lt;C-tab> :tabn&lt;cr> map &lt;C-S-tab> :tabp&lt;cr> \" no highlight map &lt;leader>/ :nohl&lt;cr> \" Merge selected text into one line vmap &lt;leader>m J \" change all the tab into space nmap &lt;leader>rt :retab!&lt;cr> \" update when diff two files nmap &lt;leader>du :diffupdate&lt;cr> \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"copy and paste \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"map &lt;C-A> ggVG \"map! &lt;C-A> &lt;Esc>ggVG \" copy \"vmap &lt;C-c> \"+y \" cut \"vmap &lt;C-x> \"+x \" paste nmap &lt;leader>p \"+gP \"back to file nmap &lt;leader>b :bf&lt;CR> nmap gt &lt;C-w>gf vnoremap gt &lt;C-w>gf \" tab to indent and shift-tab to unindent nmap &lt;tab> >> vmap &lt;tab> >gv nmap &lt;S-tab> &lt;&lt; vmap &lt;S-tab> &lt;gv imap &lt;S-tab> &lt;ESC>&lt;&lt;i \"visual block key i behaves like &lt;shift-i> vnoremap &lt;expr> i mode()=~'\\cv' ? 'i' : 'I' vnoremap &lt;expr> a mode()=~'\\cv' ? 'a' : 'A' \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"auto complete (),[],{}and so on \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" :inoremap ( ()&lt;Left> :inoremap ) &lt;c-r>=ClosePair(')')&lt;CR> :inoremap { {}&lt;Left> autocmd FileType c,cpp :inoremap { {&lt;CR>}&lt;ESC>O :inoremap } &lt;c-r>=ClosePair('}')&lt;CR> :inoremap [ []&lt;Left> :inoremap ] &lt;c-r>=ClosePair(']')&lt;CR> :inoremap \" \"\"&lt;Left> \"autocmd Filetype c,cpp,python,perl :inoremap ' ''&lt;ESC>i function! ClosePair(char) if getline('.')[col('.') - 1] == a:char return \"\\&lt;Right>\" else return a:char endif endfunction \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"自动插入文件头 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" autocmd! BufNewFile * silent! 0r ~/.vim/skel/Template.%:e autocmd! BufNewFile *.cpp,*.[ch],*.sh,*.java,*.v,*.sv,*.vhd,*.py exec \":call SetTitle()\" function! SetTitle() \"如果文件类型为脚本文件 if &amp;filetype =~ 'sh\\|perl\\|python' if &amp;filetype == 'sh' call setline(1,\"#!/bin/bash\") elseif &amp;filetype == 'perl' call setline(1,\"#!/usr/bin/perl -w\") elseif &amp;filetype == 'python' call setline(1,\"#!/usr/bin/env python\") endif call append(line(\".\"), \"\") elseif &amp;filetype =~ 'verilog\\|systemverilog\\|c\\|cpp' call setline(1 , \"\\//------------------------------------------------------------------------\") call append(line(\".\") , \"\\// File Name : \".expand(\"%\")) call append(line(\".\")+1 , \"\\// Author : victor dong (dxs_uestc@163.com)\") call append(line(\".\")+2 , \"\\// Version : V0.1 \") call append(line(\".\")+3 , \"\\//------------------------------------------------------------------------\") call append(line(\".\")+4 , \"\\// Description :\" ) call append(line(\".\")+5 , \"\\// \" ) call append(line(\".\")+6 , \"\\//------------------------------------------------------------------------\") call append(line(\".\")+7 , \"\\// Revision History:\" ) call append(line(\".\")+8 , \"\\// *Version* | *Modifier* | *Modified Date* | *Description*\") call append(line(\".\")+9 , \"\\// V0.1 | Victor | \".strftime(\"%Y-%m-%d\").\" | Fisrt Created.\") call append(line(\".\")+10, \"\\//------------------------------------------------------------------------\") call append(line(\".\")+11, \"\" ) endif if &amp;filetype == 'cpp' call append(line(\".\")+12, \"#include&lt;iostream>\") call append(line(\".\")+13, \"using namespace std;\") call append(line(\".\")+14, \"\") endif if &amp;filetype == 'c' call append(line(\".\")+12, \"#include&lt;stdio.h>\") call append(line(\".\")+13, \"\") endif if &amp;filetype =~ 'verilog\\|systemverilog' if expand(\"%:r\") =~ 'tb$' call append(line(\".\")+12, \"`timescale 1ns/1ps\") call append(line(\".\")+13, \"\") call append(line(\".\")+14, \"module \".expand(\"%:r\").\"();\") call append(line(\".\")+15, \"\") call append(line(\".\")+16, \"initial begin\") call append(line(\".\")+17, \" $fsdbDumpfile(\\\"wave.fsdb\\\");\") call append(line(\".\")+18, \" $fsdbDumpvars(0);\") call append(line(\".\")+19, \"\\// $fsdbDumpMDA(0);\") call append(line(\".\")+20, \"end\") call append(line(\".\")+21, \"\") call append(line(\".\")+22, \"endmodule\") else call append(line(\".\")+12, \"module \".expand(\"%:r\").\"(\") call append(line(\".\")+13, \" input clk ,\") call append(line(\".\")+14, \" input rst_n ,\") call append(line(\".\")+15, \");\") call append(line(\".\")+16, \"\") call append(line(\".\")+17, \"\\//==============================================\") call append(line(\".\")+18, \"\\// Definition of regs and wires\") call append(line(\".\")+19, \"\\//==============================================\") call append(line(\".\")+20, \"\") call append(line(\".\")+21, \"\\//**********************************************\") call append(line(\".\")+22, \"\\// Function\") call append(line(\".\")+23, \"\\//**********************************************\") call append(line(\".\")+24, \"\") call append(line(\".\")+25, \"endmodule\") endif endif \"新建文件后，自动定位到文件末尾 exec \"normal G\" endfunc \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"\"实现上面函数中的，Last Modified功能 \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"autocmd! BufWrite,BufWritePre,FileWritePre *.cpp,*.[ch],*.sh,*.java,*.v,*.sv,*.vhd,*.py ks|call LastModified()|'s \"function! LastModified() \" if line(\"$\") > 20 \" let l = 20 \" else \" let l = line(\"$\") \" endif \" exec \"1,\".l.\"g/Last Modified: /s/Last Modified: .*/Last Modified:\". \" \\strftime(\" %Y-%m-%d %H:%M:%S\") . \"/e\" \"endfunc \" Returns true if paste mode is enabled function! HasPaste() if &amp;paste return '[PASTE MODE] ' endif return '' endfunction \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" return vim mode \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" function! Disp_Mode() let mode=mode() if mode ==# 'v' return 'Visual' elseif mode ==# 'V' return 'V-Line' elseif mode ==# '\u0016' return 'V-Block' elseif mode ==# 's' return 'Select' elseif mode ==# 'S' return 'S-Line' elseif mode ==# '\u0013' return 'S-Block' elseif mode =~# '\\vi' return 'Insert' elseif mode =~# '\\v(R|Rv)' return 'Replace' else return 'Normal' endif endfunction \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" add comment and del comment \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" autocmd BufNewFile,BufRead * map &lt;C-c> :call AddComment()&lt;CR> autocmd BufNewFile,BufRead * map &lt;S-c> :call DelComment()&lt;CR> function! AddComment() if &amp;filetype =~? 'python\\|perl\\|tcl\\|sh\\|zsh\\|csh\\|conf\\|sdc\\|make' exec 's/\\v^(\\s*)#*/#\\1/' elseif &amp;filetype =~? 'verilog\\|c\\|cpp\\|h' exec 's/\\v^(\\s*)\\/*/\\/\\/\\1/' elseif &amp;filetype ==? 'vhdl' exec 's/\\v^(\\s*)-*/--\\1/' elseif &amp;filetype ==? 'vim' exec 's/\\v^(\\s*)\\\"*/\\\"\\1/' elseif &amp;filetype == 'xml' exec 's/\\v^(.*)$/&lt;!--\\1-->' endif exec \"nohl\" endfunction function! DelComment() if &amp;filetype =~? 'python\\|perl\\|tcl\\|sh\\|zsh\\|csh\\|conf\\|sdc\\|make' exec 's/\\v^(\\s*)#*/\\1/' elseif &amp;filetype =~? 'verilog\\|c\\|cpp\\|h' exec 's/\\v^(\\s*)\\/*/\\1/' elseif &amp;filetype ==? 'vhdl' exec 's/\\v^(\\s*)-*/\\1/' elseif &amp;filetype ==? 'vim' exec 's/\\v^(\\s*)\\\"*/\\1/' elseif &amp;filetype == 'xml' exec 's/\\v^%(\\s*\\&lt;\\!--)*(.*)%(-->\\s*)*$/\\1/' endif exec \"nohl\" endfunction \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" filetype \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" au BufNewFile,BufRead readme,README setf help \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" plugin: supertab \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" let g:SuperTabDefaultCompletionType = \"context\" let g:SuperTabMappingForward = '&lt;s-space>' let g:SuperTabMappingBackward = '&lt;s-c-space>' \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" plugin: NERDTree \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \"autocmd vimenter * NERDTree autocmd bufenter * if (winnr(\"$\") == 1 &amp;&amp; exists(\"b:NERDTreeType\") &amp;&amp; b:NERDTreeType == \"primary\") | q | endif map &lt;F3> :NERDTreeToggle&lt;CR> let NERDTreeShowHidden=0 let NERDTreeWinSize=25 let NERDTreeIgnore=['\\~$', '\\.swap$', '.pyc$'] \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" \" plugin: UltiSnips \"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\" let g:UltiSnipsExpandTrigger=\"&lt;tab>\" let g:UltiSnipsJumpForwardTrigger=\"&lt;tab>\" let g:UltiSnipsJumpBackwardTrigger=\"&lt;c-b>\" \" If you want :UltiSnipsEdit to split your window. let g:UltiSnipsEditSplit=\"vertical\"","categories":[{"name":"vim","slug":"vim","permalink":"https://dxsm.github.io/categories/vim/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://dxsm.github.io/tags/vim/"},{"name":"vimrc","slug":"vimrc","permalink":"https://dxsm.github.io/tags/vimrc/"}]},{"title":"IEEE1801 UPF核心要点","slug":"upf-note","date":"2019-01-12T00:04:02.000Z","updated":"2020-03-07T09:08:15.979Z","comments":true,"path":"p/upf-note.html","link":"","permalink":"https://dxsm.github.io/p/upf-note.html","excerpt":"CPF, UPF, IEEE1801 这些名称的渊源可参阅《一文读懂power intent的历史：从CPF/UPF到IEEE1801》，1801的内容其实十分简明，概括来说一个完整的1801 文件可以分成三部分[1]： 区域划分: 上帝的归上帝，凯撒的归凯撒，包括supply set 跟power domain 两个东西。 策略定义: 没有清规戒律，何以服众，包括isolation, level shifter, retention, power switch 四种策略。 模式定义: 宿命就是划定的圈，听天由命也是宿命，只有power state.","text":"CPF, UPF, IEEE1801 这些名称的渊源可参阅《一文读懂power intent的历史：从CPF/UPF到IEEE1801》，1801的内容其实十分简明，概括来说一个完整的1801 文件可以分成三部分[1]： 区域划分: 上帝的归上帝，凯撒的归凯撒，包括supply set 跟power domain 两个东西。 策略定义: 没有清规戒律，何以服众，包括isolation, level shifter, retention, power switch 四种策略。 模式定义: 宿命就是划定的圈，听天由命也是宿命，只有power state. 在实际项目中，power domain 的划分有时候会极其复杂，会有多个1801 文件相互调用，但再复杂的设计都是上述三部分内容的集合，在面对复杂设计时，简单有效的办法是：一张图 + 一张表。 一张图：将power domain 及boundary 的关系画出来，就可以十分明确地知道需要定义多少个power domain, 每个power domain 有哪些供电电压，哪些power domain 之间需要isolation 或level shifter, 哪些power domain 需要power switch 跟retention cell. 有了图之后，剩下的事情就是用1801 的命令进行描述。 一张表：用表来描述power state, 先将每一个supply set 的power state 列出，再将系统的power mode 列出。 1. 区域划分 Supply set：从1801 开始引入supply set 的概念，supply set 很像C++ 里的&quot;类&quot;，它将所有相关的supply nets &quot;封装&quot;起来，一个supply set 包含某个instance 或power domain 所有的supply nets。1801 的标准一直在更新，现在最新的应该是IEEE1801-2015, supply set 的定义如下图： Power Domain：在逻辑上看，power domain是一组instance 的集合，集合中所有的instance 共用相同的supply set. 从物理上看，一个power domain 对应一个voltage area, 这个area 内部所有的std cell 用同一组电源和地。 需要特别说明一下 -available_supply 这个option, 默认在&quot;本power domain&quot; 或 “父power domain” 区域定义的supply set 都可供该power domain 所用，但实际项目中，并不能也不需要将所有的power 都拉到该区域，所以需要给工具指明该power domain 需要哪些supply set, 此时就需要用到这个 option: 如果没有指定-available_supply，则在&quot;本power domain&quot; 或 “父power domain” 区域定义的supply set 都可为该power domain 所用； 如果指定-available_supply 且其值为空字符串，如 {} , 那只有-supply 指定的supply set 才可以为本power domain 所用； 如果用-available_supply 指定了某个具体的 supply set, 则该power domain 除了可以用由-supply 指定的supply set 也可以用由该option 指定的supply set. Supply set in Power domain：每创建一个power domain 都会自动创建三个supply sets: Primary：定义该power domain 中所有instance 的primary power 和 primary ground。 Default retention: 用于retention cells. Default isolation：用于isolation cells 也同C++ 中对象的访问类似，可以用 “句柄” 来访问power domain 的supply set, 如：“DomainName.Supply_set”。创建power domain时自动创建的supply sets 需要同电路中的supply net 正确关联起来方可。有如下两种方式： Style1: create_supply_set SS1 -function {power VDD} create_power_domain PD1 –supply {primary SS1} Style2: create_power_domain PD1 create_supply_set SS1 -function {power VDD} associate_supply_set SS1 –handle PD1.primary 2. 策略定义 2.1 Isolation Isolation：当一条net 的driver 在shutoff power domain 而load 在more on power domain 时，该net 在跨power domain 时就需要插入isolation cell. 以保证在shutoff power domain 断电时，more on power domain 的输入被钳位到一个固定电压值而不是一个不定态。Isolation cell 在逻辑功能上可能是『二输入与』也可能是『二输入或』，其中一个输入是控制信号，用于掉电后把输出拉高或拉低，另一个输入为功能信号。通常有双电源跟单电源两种isolation cell, 双电源isolaiton cell 可以放入shutoff power domain, 一组电源接shutoff power 另一组电源接backup 电源；而单电源isolation cell 只能放入more on power domain 或more more on parents power domain. 不同的工具都在跟着IEEE 1801 标准的更新不断改进，并不是所有的工具都支持所有的option, 其实大部分isolation 的定义都不需要所有的option。在UPF1.0 中需要用set_isolation + set_isolation_control 两条命令来定义一条isolation stratage, 即使是到1801 时代，在很长一段时间，有些工具依然需要用两条命令来定义。 定义哪里需要插入 isolation： 从&quot;一张图&quot; 开始，确定需要插入isolation 的interface net. 用下面的option 来定义： 定义如何插入 Isolation： 用如下option 定义： 2.2 Level Shifter Level shifters：当一条net 的driver 跟load 在由不同电压驱动的power domain 时，该net 在跨power domain 时就需要插入level shifter cell，以确保输入信号的电平在合法范围内。通常level shifter cell 有三种：从低到高、从高到低、既能低到高也能高到低。在逻辑功能上 level shifter cell 比isolation cell 简单，就是一个buffer，但是需要两组power supply, 输入power supply 对应于driver 的supply, 输出power supply 对应于load 的supply。 理论上讲，只要net 跨越不同电压驱动的power domain 就需要插入level shifter cell, 但是如果一根信号是从高电压区域到低电压区域，且『高低电压差』在低电压区cell 可忍受范围内，则可以省去该level shifter cell. 但是通常从低电压到高电压，则一定要插入level shifter，否则可能由于电压低于load cell 翻转电压导致功能错误，而且会由于管子不能完全关断会造成持续短路电流。 level shifter rule 的定义也比isolation rule 要简单。 定义哪里需要插入 level shifter: 定义如何插入 level shifter： 2.3 Retention Retention：shut off domain 中有些寄存器非常重要，即便是掉电后其内容也需要被保留住，以保证上电后相关逻辑有个正确的起点，在低功耗设计中这些寄存器会用retention 寄存器来替换，retention 寄存器有多种结构，差别之处主要在控制信号的数目及控制方式，内部结构相差并不大。相比于普通的寄存器Rentention 寄存器内部多了一个有独立电源的latch, 这个独立电源会连到always on supply 上，当主电源掉电后，该Latch 会将寄存器掉电前最后的状态锁存住，当主电源恢复后，再将该Latch 锁存的状态读回。常见的retention cell 有如下几种，此处不展开描述，会另辟章节介绍这些低功耗cell。 Retention rule 比其他几个rule 要复杂一些，在定义retention rule 之前需要确认几点： 去lib 或lib 的doc 中确认要用到的retention cell 的控制信号是哪些，及相应的有效电平。 跟设计人员确认shut off domain 中哪些寄存器需要做retention. 确认retention cell 的backup supply是谁。 哪些寄存器需要retention： 指定retention cell 的backup supply： 指定retention cell 的控制信号： 指定用那种retention cell： 2.4 Power Switch Power Switches：用于控制shut off power domain 电源的开关，power switch 用于控制power net 故跟power plan 相关，在实现时需要精细考虑以尽量减小其造成的IR-drop. 不像其他low power cell 通常需要在综合时插入, power switch cell 是在P&amp;R 工具中插入的。通常power switch cell 有Coarse Grain 和Fine Grain 两种，更常用的是Coarse Grain, 根据切断电流通路的位置它又分Header Switch 跟Footer Switch 两中。Fine Grain 指对每个STD cell 分别关断，这要求每个STD cell 自带一个Switch 管子且有一个控制pin, 在该Domain 不工作时将supply 断开。 常见的Power Switch cell 有一个控制信号或两个控制信号用-control_port 来指定，用-on_state 来定义控制逻辑，如&quot;与或非&quot; 。 -ack_port 所指定的信号用于表示输出电压是否已稳定，这个信号通常用于其他power switch 的输入或状态机的控制。 2.5 Map to specfic cells 在大多数情况下，都需要指定某个isolation 或 level shifter stratage 可用哪些特定的lib cell, 在UPF 1.0 中会用如下命令予以指定： map_isolation_cell -lib_cells &lt;cells list> map_level_shifter_cell -lib_cells &lt;cells list> 在很多用IEEE 1801 描写的UPF 文件中，亦会用这两条命令来指定，一方面是由于工具端更新不及时，另一方面源于用户使用习惯。 在IEEE1801 中定义了新命令：use_interface_cell. 这条命令可以针对某条具体的strategy 来指定。 如果一条net 即需要插入isolation cell 也需要插入 level shifter cell 通常会用到一种带enable pin 的level shifter cell, 这类cell 有两类：一类叫enabled level shifter cell 另一种叫combo cells, 即将isolation cell 跟 level shifter cell 组合到一起的cell, 这两类cell 在library 中的定义不同，用CPF 描述时也不同，用IEEE 1801定义时，需要分别定义isolation rule 跟 level shifter rule, 然后用use_interface_cell 将两条rule 指定到组合的cell 上即可。 3. 模式定义 Power State：power state 是power intent 的&quot;状态机&quot;，用于定义设计中每个power domain 的供电状况，如哪些power domain 开启，哪些power domain 关断，哪些power domain 可工作于多个电压。CPF, UPF, 1801 都有各自定义power state的命令。 CPF: 用create_power_mode 来定义，在CPF 中power state 通常被称为power mode. UPF: 用add_port_state + create_pst + add_pst 来定义，比较繁琐。 1801: 虽然可以用upf 的命令来定义，但是强烈推荐用命令add_power_state 来定义。 如同RTL 写状态机需要画状态转移图一样，在定义power state 之前最好列一张&quot;状态表&quot;，尤其对于复杂设计而言十分必要。如下图，该设计有两个power domain: PDon: 常开电压域，工作电压1.08V，对应的supply set 是VDD + VSS. PD1: 可关断电压域, 工作电压是0.9V, 对应的supply set 是power switch 的输入VDDm + VSS; 跟power switch 的输出VDDau + VSS。 根据power domain 的划分及描述，可以列一张如下的表，列出该设计所有可能的power state 及每个power state 对应supply set 的工作电压。 1801 的power state 定义由supply set level power state 和 system level power state 两级构成。 supply set level power state: 用add_power_state + -supply_expr 定义每个supply set 的工作电压。虽然并不是必须要明确定义supply set 的power state, 但强烈推荐予以明确定义，保证良好的继承性及可读性，所见即所得。 system level power state: 用add_power_state + -logic_expr 定义不同supply set 间的交互。 supply set level power state 的定义需要注意几点： -supply_expr 中只能包含该supply set 对应的net. 在supply_expr 中可用逻辑与&quot;&amp;&amp;&quot; 表示不同supply net的状态。 -simstate 用于simulation, “normal” 对应于ON state, “corrupt” 对应于OFF state. 实现工具自动忽略该option. system level power state 的定义需要注意几点： add_power_state 后跟的object_name，C 跟S 的工具有所不同，对于C家的工具这个object_name 可以是已定义的任何一个power domain 的名字，如示例中的&quot;PDon&quot;；而对于S 家的工具目前还不支持用power domain 做object_name, 需要用命令 create_power_state_group 定义一个state group, 用这个state group 做object_name. 需要在每个-logic_expr 中将所有的supply set 的状态明确给出。 在system level power state 中不要指定-simstate. 整理自陌上风骑驴看IC ↩︎","categories":[{"name":"UPF","slug":"UPF","permalink":"https://dxsm.github.io/categories/UPF/"}],"tags":[{"name":"SOC","slug":"SOC","permalink":"https://dxsm.github.io/tags/SOC/"},{"name":"UPF","slug":"UPF","permalink":"https://dxsm.github.io/tags/UPF/"},{"name":"Low Power","slug":"Low-Power","permalink":"https://dxsm.github.io/tags/Low-Power/"}]},{"title":"AHB协议学习笔记","slug":"ahb_protocal","date":"2018-12-12T14:50:15.000Z","updated":"2020-04-11T16:02:22.165Z","comments":true,"path":"p/ahb-protocal.html","link":"","permalink":"https://dxsm.github.io/p/ahb-protocal.html","excerpt":"1. AHB组成部分 AHB主设备(master) 发起一次读写操作 某一时刻只允许一个master使用总线 AHB从设备(slave) 响应一次读写操作 通过地址映射来选择使用哪个slave AHB仲裁器(arbiter) 允许某一个主设备控制总线 在AMBA协议中没有定义仲裁算法 AHB译码器(decoder) 通过地址译码来决定选择哪个slave","text":"1. AHB组成部分 AHB主设备(master) 发起一次读写操作 某一时刻只允许一个master使用总线 AHB从设备(slave) 响应一次读写操作 通过地址映射来选择使用哪个slave AHB仲裁器(arbiter) 允许某一个主设备控制总线 在AMBA协议中没有定义仲裁算法 AHB译码器(decoder) 通过地址译码来决定选择哪个slave 2. AHB信号 Name Source To Desciption HCLK clock Source 各个module 总线时钟 HRESETn reset controller 各个module 总线复位 HADDR[31:0] master decoder/mux to slave/arbiter 32位系统地址总线 HTRANS[1:0] master mux to slave 当前传输类型: IDLE(00),BUSY(01),NONSEQ(10),SEQ(11) HWRITE master mux to slave 0:读, 1:写 HSIZE[2:0] master mux to slave 指示当前传输的大小: 000(8bit),001(16bit),010(32bit),011(64bit)… HBURST[2:0] master mux to slave/arbiter burst类型: single,incr,wrap HPROT[3:0] master mux to slave 保护机制，需要slave带有保护功能 HWDATE[31:0] master mux to slave 写数据总线 HBUSREQx master arbiter 总线接入请求 HLOCKx master arbiter master requires locked access to the bus(no other master should be granted the bus until this signal is LOW) HRDATE[31:0] slave mux to master/arbiter 读数据总线 HREADY slave mux to master/arbiter HREADY拉高表示一次传输完成，HREADY为低电平延长传输周期 HRESP[1:0] slave mux to master/arbiter 传输状态: OKAY, ERROR, RETRY, SPLIT HSPLITx[15:0] slave arbiter 告诉arbiter哪个master允许重新尝试一次split传输 HSELx decoder slave slave片选信号 HGRANTx arbiter master This signal indicates that bus master x is currently the highest priority master. A master gets access to the bus when both HREADY and HGRANTx are HIGH HMASTER[3:0] arbiter 具有split功能的slave 指出哪个master正在进行传输，提供进行split的信息 HMASTLOCK arbiter 具有split功能的slave 指出当前master正在进行一次锁定传输 3. 基本传输 AHB传输有两个阶段： Address phase: 只有一个有效周期 Data phase: 由HBURST信号决定需要几个有效周期 流水线传送：先是address phase，再是data phase。下一次address phase可以与上一次data phase在同一周期。 3.1 无等待周期的简单传输 HCLKHADDR[31:0]AControlControlHWDATA[31:0]Data(A)HREADYHRDATA[31:0]Data(A)Address phaseData phase 3.2 需要等待两个周期的简单传输 slave通过拉低hready信号延长传输周期(协议规定最大不能超过16个周期)，注意： 对于写传输，master在延长周期内必须保持HWDATA数据稳定 对于读传输，slave在延长周期不需要提供有效的HRDATA HCLKHADDR[31:0]AControlControlHWDATA[31:0]Data(A)HREADYHRDATA[31:0]Data(A)Address phaseData phase 3.3 Pipeline传输 HCLKHADDR[31:0]ABCControlControl(A)Control(B)Control(C)HWDATA[31:0]Data(A)Data(B)Data(C)HREADYHRDATA[31:0]Data(A)Data(B)Data(C) 4. burst传输 4.1 传输类型 HTRANS[1:0] Type Description 00 IDLE master占用总线，但没有进行传输 01 BUSY master占用总线，但在burst传输过程中还没有准备好下一次传输，地址和控制信息必须反映下一次传输 10 NONSEQ 表明一次单个数据的传输或者一次burst传输的第一个数据，地址和控制信号与上一次传输无关 11 SEQ 表明burst传输接下来的数据，地址和上一次传输的地址是相关的，控制信息与上一次传输是相同的 4.2 burst类型 HBURST[2:0] Type Desciption 000 SINGLE 单次传输 001 INCR 未定义长度incrementing传输 010 WRAP4 4-beat wraping burst 011 INCR4 4-beat incrementing burst 100 WRAP8 8-beat wraping burst 101 INCR8 8-beat incrementing burst 110 WRAP16 16-beat wraping burst 111 INCR16 16-beat incrementing burst 4.3 未定义长度INCR传输 INCR传输HADDR累加值与HSIZE有关，每次加2HSIZE Burst传输不能跨越1K边界，即到达1K边界需要用NONSEQ发起一次新的传输 ❓思考：为什么burst传输不能跨越1K边界？ ARM的回答：The 1KB restriction you refer to is not a restriction on maximum slave size but a constraint within AHB that says that a burst must not cross a 1KB boundary. The limit is designed to prevent bursts crossing from one device to another and to give a reasonable trade-off between burst size and efficiency. In practise, this means that a master must ALWAYS break a burst that would otherwise cross the 1KB boundary and restart it with a non-sequential transfer. 图4.3.1 未定义长度INCR传输HCLKHTRANS[1:0]NONSEQSEQNONSEQSEQSEQHADDR[31:0]0x200x220x5C0x600x64HBURST[2:0]INCRINCRHSIZE[2:0]001010HWDATA[31:0]Data(0x20)Data(0x22)Data(0x5C)Data(0x60)Data(0x64)HREADYHRDATA[31:0]Data(0x20)Data(0x22)Data(0x5C)Data(0x60)Data(0x64) 图4.3.2 未定义长度INCR跨1K边界HCLKHTRANS[1:0]NONSEQSEQSEQNONSEQSEQSEQHADDR[31:0]0x3F40x3F80x3FC0x4000x4040x408HBURST[2:0]INCRHSIZE[2:0]010HWDATA[31:0]Data(0x3F4)Data(0x3F8)Data(0x3FC)Data(0x400)Data(0x404)Data(0x408)HREADYHRDATA[31:0]Data(0x3F4)Data(0x3F8)Data(0x3FC)Data(0x400)Data(0x404)Data(0x408) 4.4 WRAP传输 ❓思考：如何确定WRAP边界？ wrap的边界与HSIZE和HBURST都有关系，对于WRAP4来说，HADDR[HSIZE+1:HSIZE]==2’b11就是边界；对于WRAP8来说，HADDR[HSIZE+2:HSIZE]==2’b111就是边界，同理适用于WRAP16。 假如：HSIZE=3’b010时，HADDR起始地址为0x48 当HBURST为WRAP4时，HADDR依次为0x48 -&gt; 0x4C -&gt; 0x40 -&gt; 0x44(对应的HADDR[3:2]依次为2’b10 -&gt; 2’b11 -&gt; 2’b00 -&gt; 2’b01) 当HBURST为WRAP8时，HADDR依次为0x48 -&gt; 0x4C -&gt; 0x50 -&gt; 0x54 -&gt; 0x58 -&gt; 0x5C -&gt; 0x40 -&gt; 0x44(对应的HADDR[4:2]依次为3’b010 -&gt; 3’b011 -&gt; 3’b100 -&gt; 3’b101 -&gt; 3’b110 -&gt; 3’b111 -&gt; 3’b000 -&gt; 3’b001) 图4.4.1 WRAP4传输HCLKHTRANS[1:0]NONSEQSEQSEQSEQHADDR[31:0]0x480x4C0x400x44HBURST[2:0]WRAP4HSIZE[2:0]010HWDATA[31:0]Data(0x48)Data(0x4C)Data(0x40)Data(0x44)HREADYHRDATA[31:0]Data(0x48)Data(0x4C)Data(0x40)Data(0x44) 5. 总结 slave短时间内无法响应：将HREADY拉低 slave长时间无法响应：插入SPIT/RETRY master不能传输，插入BUSY 总线上如果只有一个master，可以使用AHB lite协议，即没有arbiter，不支持retry和split响应 AHB中hready的含义 对于slave来说,进来的hready_i代表的是bus上的状态低就表示bus被人(可能是他自己)使用着,hready_o代表它自身的状态,低代表它要占用bus 对于arbiter来说,从slave进来的hready_i代表各个slave占用bus的状态,返回给slave的hready是所有的hready_i做and运算之后的结果,同时这个也返回给master 对于master来说,hready_i拉低代表bus忙,不能使用","categories":[{"name":"SOC设计","slug":"SOC设计","permalink":"https://dxsm.github.io/categories/SOC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"AMBA","slug":"AMBA","permalink":"https://dxsm.github.io/tags/AMBA/"},{"name":"SOC","slug":"SOC","permalink":"https://dxsm.github.io/tags/SOC/"}]},{"title":"testbench如何force vhdl内部信号","slug":"nc_force_usage","date":"2018-10-02T14:50:15.000Z","updated":"2020-03-07T09:08:15.973Z","comments":true,"path":"p/nc-force-usage.html","link":"","permalink":"https://dxsm.github.io/p/nc-force-usage.html","excerpt":"force verilog内部信号 force verilog内部信号为某个值，可以这样写： initial begin //verilog internal signal access force xxx.xxx.xxx = 16'hfffd; #500 release xxx.xxx.xxx; end force vhdl内部信号 而对于vhdl内部信号，使用force是错误的，vhdl语言不允许这样做。但是EDA工具一般都会提供函数，例如cadence的ncsim，可以使用$nc_force和nc_release访问vhdl内部信号。 initial begin //vhdl internal signal access $nc_force(\"xxx.xxx.xxx\", \"X'FFFD'\"); #500 $nc_release(xxx.xxx.xxx); end","text":"force verilog内部信号 force verilog内部信号为某个值，可以这样写： initial begin //verilog internal signal access force xxx.xxx.xxx = 16'hfffd; #500 release xxx.xxx.xxx; end force vhdl内部信号 而对于vhdl内部信号，使用force是错误的，vhdl语言不允许这样做。但是EDA工具一般都会提供函数，例如cadence的ncsim，可以使用$nc_force和nc_release访问vhdl内部信号。 initial begin //vhdl internal signal access $nc_force(\"xxx.xxx.xxx\", \"X'FFFD'\"); #500 $nc_release(xxx.xxx.xxx); end cadence工具debug小技巧 使用cadence工具编译出错，看不懂error解释时，可以使用nchelp获取更详细的解释或解决办法。例如编译时出现如下错误： 可以在terminal敲入命令nchelp ncsim SETNEL得到详细帮助如下：","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"testbench","slug":"testbench","permalink":"https://dxsm.github.io/tags/testbench/"}]},{"title":"systemverilog面向对象","slug":"sv_learning_chap4","date":"2018-09-30T14:50:15.000Z","updated":"2020-03-07T09:08:15.978Z","comments":true,"path":"p/sv-learning-chap4.html","link":"","permalink":"https://dxsm.github.io/p/sv-learning-chap4.html","excerpt":"类封装了数据和操作这些数据的子程序 类可以定义在program、package、module中，或者在这些块之外的任何地方。类应当在program或者module之外的package中定义，避免与其他块内变量出现冲突。 new()创建对象、分配空间并执行构造函数 赋值为null释放对象空间 通过static来声明静态变量，是的该变量被该类的所有实例所共享，但使用范围仅限于该类 通过类名::变量来访问静态变量 静态变量在声明时初始化 静态方法跟静态变量类似，也通过static声明 静态方法不允许读写非静态变量 类中的方法默认是自动存储的 当使用一个变量时，会优先在当前作用域中寻找，接着在上一级作用域寻找，直到找到该变量为止。this可以明确指定当前作用域。","text":"类封装了数据和操作这些数据的子程序 类可以定义在program、package、module中，或者在这些块之外的任何地方。类应当在program或者module之外的package中定义，避免与其他块内变量出现冲突。 new()创建对象、分配空间并执行构造函数 赋值为null释放对象空间 通过static来声明静态变量，是的该变量被该类的所有实例所共享，但使用范围仅限于该类 通过类名::变量来访问静态变量 静态变量在声明时初始化 静态方法跟静态变量类似，也通过static声明 静态方法不允许读写非静态变量 类中的方法默认是自动存储的 当使用一个变量时，会优先在当前作用域中寻找，接着在上一级作用域寻找，直到找到该变量为止。this可以明确指定当前作用域。","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"systemverilog","slug":"systemverilog","permalink":"https://dxsm.github.io/tags/systemverilog/"}]},{"title":"systemverilog接口以及搭建测试环境","slug":"sv_learning_chap3","date":"2018-09-29T14:50:15.000Z","updated":"2020-03-07T09:08:15.977Z","comments":true,"path":"p/sv-learning-chap3.html","link":"","permalink":"https://dxsm.github.io/p/sv-learning-chap3.html","excerpt":"接口信号必须使用非阻塞赋值来驱动 modport将信号分组并指定方向 clocking时钟块用于控制同步信号的时序 testbench注意事项： $exit用于结束程序块，$finish用于结束仿真 时钟产生不应该放在program程序块中，会引起信号的竞争，而应该放在module中 例化时如果端口名字和数据类型一致，例化时可以用.*(隐式端口连接) DUT代码 以简单的乘法器为例写testbench //mul.v module mul( input clk, input rst_n, input in_vld, input [11:0] mul_ain, input [11:0] mul_bin, output reg [22:0] mul_out, output reg out_vld ); always @(posedge clk) if(in_vld) mul_out &lt;= $signed(mul_ain) * $signed(mul_bin); always @(posedge clk,negedge rst_n) if(!rst_n) out_vld &lt;= 1'b0; else out_vld &lt;= in_vld; endmodule","text":"接口信号必须使用非阻塞赋值来驱动 modport将信号分组并指定方向 clocking时钟块用于控制同步信号的时序 testbench注意事项： $exit用于结束程序块，$finish用于结束仿真 时钟产生不应该放在program程序块中，会引起信号的竞争，而应该放在module中 例化时如果端口名字和数据类型一致，例化时可以用.*(隐式端口连接) DUT代码 以简单的乘法器为例写testbench //mul.v module mul( input clk, input rst_n, input in_vld, input [11:0] mul_ain, input [11:0] mul_bin, output reg [22:0] mul_out, output reg out_vld ); always @(posedge clk) if(in_vld) mul_out &lt;= $signed(mul_ain) * $signed(mul_bin); always @(posedge clk,negedge rst_n) if(!rst_n) out_vld &lt;= 1'b0; else out_vld &lt;= in_vld; endmodule interface代码 //mul_if.sv interface mul_if(input bit clk); logic clk; logic rst_n; logic in_vld; logic [11:0] mul_ain; logic [11:0] mul_bin; logic [22:0] mul_out; logic out_vld; //define clock block clocking cb(@posedge clk); output in_vld; output mul_ain; output mul_bin; endclocking //Driver port direction modport DRV( clocking cb, output rst_n ); //DUT port direction modport DUT( input rst_n, input in_vld, input mul_ain, input mul_bin, output mul_out, output out_vld ); endinterface Driver代码 //driver.sv program driver(mul_if.DRV mulif); initial begin //reset value mulif.rst_n &lt;= 1'b0; mulif.cb.in_vld &lt;= 1'b0; //release reset #37 mulif.rst_n &lt;= 1'b1; repeat(10) begin ##1 mulif.cb.in_vld &lt;= 1'b1; //drive data @(posedge clk), ##1 means delay 1 clock mulif.cb.mul_ain &lt;= $random; mulif.cb.mul_bin &lt;= $random; end ##1 mulif.cb.in_vld &lt;= 1'b0; repeat(5) @mulif.cb; //wait posedge clk $finish; end endprogram tb_top代码 //tb_top.sv module tb_top(); bit clk; always #5 clk = ~clk; mul_if mulif(clk); driver u_drv(mulif); mul u_mul( .clk (clk), .rst_n (mulif.DUT.rst_n), .in_vld (mulif.DUT.in_vld), .mul_ain (mulif.DUT.mul_ain), .mul_bin (mulif.DUT.mul_bin), .mul_out (mulif.DUT.mul_out), .out_vld (mulif.DUT.out_vld) ) initial begin $fsdbDumpfile(\"wave.fsdb\"); $fsdbDumpvars(0); end endmodule 仿真波形","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"systemverilog","slug":"systemverilog","permalink":"https://dxsm.github.io/tags/systemverilog/"}]},{"title":"systemverilog任务、函数、program","slug":"sv_learning_chap2","date":"2018-09-28T14:50:15.000Z","updated":"2020-03-07T09:08:15.976Z","comments":true,"path":"p/sv-learning-chap2.html","link":"","permalink":"https://dxsm.github.io/p/sv-learning-chap2.html","excerpt":"缺省情况下参数的类型是与其前一个参数相同的，而第一个参数的缺省类型是logic单bit输入 参数的传递方式可以使用ref指定为引用，通常用于数组引用；当不希望子程序改变数组值时，可以使用const ref类型 ref参数只能被用于带自动存储(automatic)的子程序中，即使用ref参数时子程序必须指明automatic属性 自动存储相对的是静态存储，当多个地方调用静态存储子程序时，不同的线程之间会窜用这些局部变量，而自动存储能够迫使仿真器使用堆栈存储局部变量 函数使用return返回一个值，调用时可以使用void忽略返回值，例如void'($fscanf(file,&quot;%d&quot;,i)); module test_func(); int arr[]; //************************************ // operator = \"+\", return a.sum // operator = \"x\", return a.product //************************************ function automatic int alu( const ref int a[], //数组引用,const不能改变数组 input string operator = \"+\" //指定default值 ); int result; if(operator==\"x\") begin result = 1; for(a[i]) result *= a[i]; end else begin result = 0; for(a[i]) result += a[i]; end return result; endfunction initial begin arr = new[5]; arr = '{1,2,3,4,5}; $display(alu(arr)); //15, use default operator $display(alu(arr,\"x\")) //120 end endmodule","text":"缺省情况下参数的类型是与其前一个参数相同的，而第一个参数的缺省类型是logic单bit输入 参数的传递方式可以使用ref指定为引用，通常用于数组引用；当不希望子程序改变数组值时，可以使用const ref类型 ref参数只能被用于带自动存储(automatic)的子程序中，即使用ref参数时子程序必须指明automatic属性 自动存储相对的是静态存储，当多个地方调用静态存储子程序时，不同的线程之间会窜用这些局部变量，而自动存储能够迫使仿真器使用堆栈存储局部变量 函数使用return返回一个值，调用时可以使用void忽略返回值，例如void'($fscanf(file,&quot;%d&quot;,i)); module test_func(); int arr[]; //************************************ // operator = \"+\", return a.sum // operator = \"x\", return a.product //************************************ function automatic int alu( const ref int a[], //数组引用,const不能改变数组 input string operator = \"+\" //指定default值 ); int result; if(operator==\"x\") begin result = 1; for(a[i]) result *= a[i]; end else begin result = 0; for(a[i]) result += a[i]; end return result; endfunction initial begin arr = new[5]; arr = '{1,2,3,4,5}; $display(alu(arr)); //15, use default operator $display(alu(arr,\"x\")) //120 end endmodule program program与module相同点 和module相同，program也可以定义0个或多个输入、输出、双向端口。 一个program块内部可以包含0个或多个initial块、generate块、specparam语句、连续赋值语句、并发断言、timeunit声明。 在program块中数据类型、数据声明、函数和任务的定义均与module块类似。 一个设计中可以包含多个program块，这些program块既可以通过端口交互，也可以相互独立，这一点与module块也是相似的。 program与module不同点 一个program块不能包含任何always块，用户自定义原语(UDP)，module块、接口(interface)、program块 module中可以定义program块 一个program块可以调用其他module块或者program块中定义的函数或任务，但是一个module块却不能调用其他program块中定义的任务或函数。 program块中变量只能用阻塞赋值，不能使用非阻塞赋值","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"systemverilog","slug":"systemverilog","permalink":"https://dxsm.github.io/tags/systemverilog/"}]},{"title":"systemverilog基础","slug":"sv_learning_chap1","date":"2018-09-27T14:50:15.000Z","updated":"2020-03-07T09:08:15.975Z","comments":true,"path":"p/sv-learning-chap1.html","link":"","permalink":"https://dxsm.github.io/p/sv-learning-chap1.html","excerpt":"1. 内建数据类型 四状态：reg, wire, logic, integer, time(默认值为X) 双状态：bit, int, byte, shortint, longint, real(默认值为0) 有符号数：int, byte, shortint, longint, integer(可以使用unsigned申明为无符号数) 🔖 $isunknown操作符: 作用：使用$isunknown操作符，可以在表达式的任意位出现X或Z时返回1 //test_isunknown.sv module test_isunknown(); logic [3:0] din; initial begin din = 4'b1001; //Unknown not found! din = 4'b1x01; //Unknown is detected! din = 4'b1z01; //Unknown is detected! if($isunknown(din)) $display(\"Unknown is detected!\"); else $display(\"Unknown not found!\"); end endmodule","text":"1. 内建数据类型 四状态：reg, wire, logic, integer, time(默认值为X) 双状态：bit, int, byte, shortint, longint, real(默认值为0) 有符号数：int, byte, shortint, longint, integer(可以使用unsigned申明为无符号数) 🔖 $isunknown操作符: 作用：使用$isunknown操作符，可以在表达式的任意位出现X或Z时返回1 //test_isunknown.sv module test_isunknown(); logic [3:0] din; initial begin din = 4'b1001; //Unknown not found! din = 4'b1x01; //Unknown is detected! din = 4'b1z01; //Unknown is detected! if($isunknown(din)) $display(\"Unknown is detected!\"); else $display(\"Unknown not found!\"); end endmodule 2. 数组 2.1 数组初始化、比较、 复制、循环 循环使用for或foreach //test_array.sv module test_array(); // array initial int mem1[4] = '{1,2,3,4}; int mem2[4] = '{4{8}}; //'{8,8,8,8} //int mem3[5] = '{9,8,default:1}; //'{9,8,1,1,1} my eda tool does not support int arr[4][4] = '{ '{0,1,2,3}, '{1,2,3,4}, '{2,3,4,5}, '{3,4,5,6} }; initial begin //array compare $display(\"mem1 %s mem2\", (mem1==mem2) ? \"==\" : \"!=\"); //mem1 != mem2 //array copy mem2 = mem1; $display(\"mem1 %s mem2\", (mem1==mem2) ? \"==\" : \"!=\"); //mem1 == mem2 //array loop $display({20{\"=\"}}); //seperate line foreach(arr[i][j]) $display(\"arr[%0d][%0d] = %0d\", i, j, arr[i][j]); $display({20{\"=\"}}); //seperate line foreach(arr[i]) begin foreach(arr[,j]) if(j>=i) $write(\"%3d\",arr[i][j]); else $write(\"%3s\",\"\"); $display; end end endmodule 运行结果如下： 2.2 动态数组 分配空间new[] 分配空间并复制new[](arr) 释放空间arr.delete() 当数组(动态或定宽)复制给一个动态数组时，会调用构造函数new[]分配空间并复制数据 $size(arr)返回数组宽度 module dyn_array(); // declare and initial int dyn[]; int arr[3] = '{9,7,8}; initial begin //分配空间 dyn = new[5]; foreach(dyn[i]) dyn[i] = i; //'{1,2,3,4,5} //分配空间并复制 dyn = new[10](dyn); //'{1,2,3,4,5,0,0,0,0,0} dyn = arr; //'{9,7,8} //重新分配空间，旧值不复存在 dyn = new[3]; //'{0,0,0} //释放空间 dyn.delete(); $display($size(dyn)); //0 end endmodule 2.3 队列 声明q[$] $表示队列索引的最大值或最小值，[$:2]代表[0:2]，[1: ​$]代表[1: ​$size(q)-1]，不是所有仿真器都支持$表示最小值 q.insert(idx,value), 在idx之前插入元素或者队列，不是所有仿真器都支持插入队列 q.delete(idx), 删除第idx个元素 q.push_front(value), 在队列前面插入元素，等价于q={value,q} q.push_back(value), 在队列末尾插入元素，等价于q={q,value} q.pop_front, 从队列前面移出元素，等价于j=q[0]; q=q[1: $] q.pop_back, 从队列末尾移出元素，等价于j=q[$]; q=q[0: $-1] q.delete(), 清空队列，等价于q={} 可以把定宽或动态数组复制给队列 队列遍历也可以使用for和foreach module queue(); // declare and initial int q[$] = {0,2,5}; int q1[$] = {3,4}; int arr[4] = '{9,8,7,6}; int j = 1; initial begin q.insert(1,j); //{0,1,2,5} //q.insert(3,q1); //{0,1,2,3,4,5}, my eda tool does not support insert queue q = {q[0:2],q1,q[$]}; //{0,1,2,3,4,5}, use concat instead of insert function q.delete(1); //{0,2,3,4,5} q.push_front(6); //{6,0,2,3,4,5} q.push_back(8); //{6,0,2,3,4,5,8} j = q.pop_front; //{0,2,3,4,5,8}, j=6 j = q.pop_back; //{0,2,3,4,5}, j=8 q = arr; //{9,8,7,6}, copy array to queue q.delete(); //empty queue $display(\"%0d\", $size(q)); //0 end endmodule 2.4 数组常用方法 arr.sum, 返回数组所有元素和 arr.product, 返回数组所有元素积 arr.and, 返回数组所有元素的与 arr.or, 返回数组所有元素的或 arr.xor, 返回数组所有元素的异或 arr.min(), 返回数组中的最小值队列(注意：返回的是队列，而不是标量) arr.max(), 返回数组中的最大值队列(注意：返回的是队列，而不是标量) arr.unique(), 返回数组中具有唯一值的队列 arr.find with (condition), 返回满足条件元素的队列 arr.find_index with (condition), 返回满足条件元素下标的队列 arr.find_first with (condition), 返回满足条件第一个元素的队列 arr.find_first_index with (condition), 返回满足条件第一个元素下标的队列 arr.find_last with (condition), 返回满足条件第最后一个元素的队列 arr.find_last_index with (condition), 返回满足条件最后一个元素下标的队列 arr.reverse(), 数组反向 arr.sort(), 数组从小到大排序 arr.rsort(), 数组从大到小排序 arr.shuffle(), 数组打乱顺序 其中reverse和shuffle方法不能带with条件语句，它们的作用范围是整个数组 module array(); int arr[] = '{9,1,8,6,3,4,6,11,4}; int q[$]; initial begin //reduce operator(return value) $display(arr.sum); //52 $display(arr.product); //1368576 $display(arr.and); //0 $display(arr.or); //15 $display(arr.xor); //8 //min,max,unique(return queue) q = arr.min(); //{1} q = arr.max(); //{11} q = arr.unique(); //{9,1,8,6,3,4,11} //find operator(return queue) q = arr.find with (item>3); //{9,8,6,4,6,11,4} q = arr.find_index(x) with (x>3); //{0,2,3,5,6,7,8}, with的默认变量为item，也可以改为其他的 q = arr.find_first with (item&lt;4); //{1} q = arr.find_first_index with (item==6); //{3} q = arr.find_last with (item&lt;4); //{3} q = arr.find_last_index with (item==6); //{6} //sort operator(array changed) arr.reverse(); //{4,11,6,4,3,6,8,1,9} arr.sort(); //{1,3,4,4,6,6,8,9,11} arr.rsort(); //{11,9,8,6,6,4,4,3,1} arr.shuffle(); //{9,6,3,4,4,11,6,1,8}, 不同仿真器洗牌的结果是否一致？ end endmodule 3. 字符串 s.getc(N), 返回位置N上的字节 s.tolower(), 返回所有字符小写字符串 s.toupper(), 返回所有字符大写字符串 s.putc(N,C), 将字节C写到字符串的N位，N必须在0~len-1之间 s.substr(start,end), 返回从start到end之间所有字符 s.len(), 返回字符串长度 $psprintf(), 返回一个格式化的临时字符串，可以直接传递给其他子函数 module test_string(); string s; initial begin s = \"IEeE \"; $display(\"%s\", s.getc(0)); //I $display(s.tolower()); //ieee s = s.toupper(); //IEEE s.putc(s.len()-1, \"-\"); //IEEE- s = {s, \"P1800\"}; //IEEE-P1800 $display(s.substr(2,5)); //EE-P $display($psprintf(\"%s %0d\",s,42)); //IEEE-P1800 42 end endmodule","categories":[{"name":"ASIC验证","slug":"ASIC验证","permalink":"https://dxsm.github.io/categories/ASIC%E9%AA%8C%E8%AF%81/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"systemverilog","slug":"systemverilog","permalink":"https://dxsm.github.io/tags/systemverilog/"}]},{"title":"ASIC设计经典笔试题收录","slug":"asic_design_example","date":"2018-09-26T14:50:15.000Z","updated":"2020-03-07T09:08:15.863Z","comments":true,"path":"p/asic-design-example.html","link":"","permalink":"https://dxsm.github.io/p/asic-design-example.html","excerpt":"时序优化题 问：CLK-&gt;Q的时间为0.5ns，组合逻辑cm0、cm1延时均为7ns，在不增加流水线数目(pipeline stage)的前提下，怎么修改电路，才能让CLK达到100MHZ？(提示：C宽为2bit)","text":"时序优化题 问：CLK-&gt;Q的时间为0.5ns，组合逻辑cm0、cm1延时均为7ns，在不增加流水线数目(pipeline stage)的前提下，怎么修改电路，才能让CLK达到100MHZ？(提示：C宽为2bit) 答：放置4个cm1，分别用定值00、01、10、11作为输入，在D前放置4-to-1 Mux，将cm0输出作为选择信号，目的是将cm1的7ns替换为Mux Cell的延时。(逻辑复制，面积换时间)","categories":[{"name":"ASIC设计","slug":"ASIC设计","permalink":"https://dxsm.github.io/categories/ASIC%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://dxsm.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"}]},{"title":"EDA工具使用","slug":"eda_irun","date":"2018-09-25T12:46:02.000Z","updated":"2020-03-07T09:08:15.966Z","comments":true,"path":"p/eda-irun.html","link":"","permalink":"https://dxsm.github.io/p/eda-irun.html","excerpt":"cadence irun命令 常用编译 irun +access+wr -smartorder -clean -ntcnotchks -V93 -vtimescale 1ns/1ps -work chip_lib -f xxx.vc -top tb_top -64 coverage选项 -covtest xxx -coverage all -covoverwrite -covfile covfile.ccf -covworkdir ./cov_work 其中covfile.ccf定义coverage内容 set_expr_scoring -all set_fsm_scoring -hold_tansition set_libcell_scoring set_implicit_block_scoring -off set_covergroup -per_instance_default_one select_coverage -all -instance tb_top.xxx*...","text":"cadence irun命令 常用编译 irun +access+wr -smartorder -clean -ntcnotchks -V93 -vtimescale 1ns/1ps -work chip_lib -f xxx.vc -top tb_top -64 coverage选项 -covtest xxx -coverage all -covoverwrite -covfile covfile.ccf -covworkdir ./cov_work 其中covfile.ccf定义coverage内容 set_expr_scoring -all set_fsm_scoring -hold_tansition set_libcell_scoring set_implicit_block_scoring -off set_covergroup -per_instance_default_one select_coverage -all -instance tb_top.xxx*... Synopsys Verdi vhdlcom -v93 -sup_sem_error -smartorder -work chip_lib -f vhdl.flist vericom -sv +systemverilogext+sv +v95ext+v95 +verilog2001ext+v -ignorekwd_config -work chip_lib -f verilog.flist verdi -lib chip_lib -top xxx -ssf xxx.fsdb cadence imc命令 coverage merge: imc -exec cov_merge.tcl 其中cov_merge.tcl如下： merge -runfile runfile -metrics code:fsm:block:expression:toggle:assertion:covergroup -out merge_data -overwrite -message 1 -initial_model union_all load -run merge_data report -detail -html -showempty on -overwrite -grading covered -source on -out nc_cov_report 其中runfile列出需要merge的coverage路径 ./cov_work/scope/case1 ./cov_work/scope/case2 ./cov_work/scope/case3* NaN","categories":[{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/categories/eda-tools/"}],"tags":[{"name":"ASIC","slug":"ASIC","permalink":"https://dxsm.github.io/tags/ASIC/"},{"name":"eda_tools","slug":"eda-tools","permalink":"https://dxsm.github.io/tags/eda-tools/"}]},{"title":"Linux小技巧","slug":"linux_tips","date":"2018-09-24T14:50:15.000Z","updated":"2020-03-07T09:08:15.971Z","comments":true,"path":"p/linux-tips.html","link":"","permalink":"https://dxsm.github.io/p/linux-tips.html","excerpt":"1. 一行执行多条命令 分号 ： 顺序地独立执行各条命令， 彼此之间不关心是否失败， 所有命令都会执行。 &amp;&amp; ： 顺序执行各条命令， 只有当前一个执行成功时候， 才执行后面的。 || ： 顺序执行各条命令， 只有当前面一个执行失败的时候， 才执行后面的。 2. 搜索已经使用的命令 ctrl+r 先按ctrl+r，然后输入要搜索的字符串即可。","text":"1. 一行执行多条命令 分号 ： 顺序地独立执行各条命令， 彼此之间不关心是否失败， 所有命令都会执行。 &amp;&amp; ： 顺序执行各条命令， 只有当前一个执行成功时候， 才执行后面的。 || ： 顺序执行各条命令， 只有当前面一个执行失败的时候， 才执行后面的。 2. 搜索已经使用的命令 ctrl+r 先按ctrl+r，然后输入要搜索的字符串即可。 3. 读压缩后的文件 读log文件常用的命令有cat、less、tail、grep等，但如果文件被压缩了，这些命令读出来的就是乱码，我们可以使用zcat、zless、zgrep等命令读取压缩的文本文件。 4. 获取上次命令的last item(!$) 可以使用!$获取上次命令的选项 5. 获取上次命令(!!) 可以使用!!获取上次命令","categories":[{"name":"Linux","slug":"Linux","permalink":"https://dxsm.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://dxsm.github.io/tags/Linux/"}]},{"title":"孩子教养推荐书籍","slug":"education_book","date":"2018-09-23T14:50:15.000Z","updated":"2020-03-07T09:08:15.967Z","comments":true,"path":"p/education-book.html","link":"","permalink":"https://dxsm.github.io/p/education-book.html","excerpt":"父母效能训练手册 9.1 (583人评价) 作者: 戈登 出版社: 天津社会科学院出版社 出版年: 2009-6-1 评语：即P.E.T，经典的亲子沟通图书。系统解决亲子沟通协商的难题。 正面管教 8.8 (1607人评价) 作者: [美] 简·尼尔森 (Jane Nelsen) 出版社: 京华出版社 出版年: 2009-1 评语：挺精彩。以阿德勒理论为基础","text":"父母效能训练手册 9.1 (583人评价) 作者: 戈登 出版社: 天津社会科学院出版社 出版年: 2009-6-1 评语：即P.E.T，经典的亲子沟通图书。系统解决亲子沟通协商的难题。 正面管教 8.8 (1607人评价) 作者: [美] 简·尼尔森 (Jane Nelsen) 出版社: 京华出版社 出版年: 2009-1 评语：挺精彩。以阿德勒理论为基础 培养高情商的孩子 8.5 (243人评价) 作者: 约翰 戈特曼 出版社: 浙江人民出版社 出版年: 2014-2-1 评语：戈特曼的经典作品。原书英文名可译为：教养之道——培养高情商的孩子 无条件养育 8.6 (408人评价) 作者: 艾尔菲·科恩 出版社: 天津教育出版社 出版年: 2012-6 评语：很精彩，以自我决定论为理论基础。注重在育儿中培养孩子的内在动机。我认为这本书代表了教养未来的发展方向。不过操作性略有不足。本书译文读起来不够流畅，引用心理学实验较多，家长阅读可能稍有困难。 看见成长的自己 8.0 (613人评价) 作者: 卡罗尔·徳韦克 出版社: 中信出版社 出版年: 2011-6 评语：虽然这本书只有一章谈育儿。但德维克介绍了一种非常重要的成长型思维模式growth mindset。对成人和儿童发展都极具指导性。为什么要鼓励不要表扬，儿童做事遇挫时家长该如何鼓励？如何培养孩子的抗挫力和坚韧性（grit）？在本书都能获得很大启发。 加州大学伯克利分校的10堂幸福教养课 8.8 (13人评价) 作者: 克莉斯汀·卡特 出版社: 中国青年出版社 出版年: 2012-1 评语：国外著名高校的积极教养幸福课。将积极心理学应用于教养中 如何培养孩子的社会能力 8.1 (180人评价) 作者: 默娜·R.舒尔 出版社: 京华 出版年: 2009-8 评语：“我能解决同伴间的冲突” i can problem solve.适用于3-7岁。“解决同伴间的问题和解决数学题一样重要”。 全脑教养法 8.5 (310人评价) 作者: 丹尼尔·西格尔 出版社: 浙江人民出版社 出版年: 2013-4 评语：非常好读，简明清晰却不失深刻的脑科学与教养读本 游戏力 8.6 (735人评价) 作者: Lawrence J. Cohen, Ph.D. 出版社: 军事谊文出版社 出版年: 2011-5-1 评语：游戏疗法在教养中的应用，弥补了一般教养过于“正儿八经”的“缺憾”。 第56号教室的奇迹 8.6 (1430人评价) 作者: 雷夫•艾斯奎斯（Rafe Espuith） 出版社: 中国城市出版社 出版年: 2009 评语：全美最佳老师的分享，充满教育智慧。适用于小学年龄。 如何说孩子才会听，怎么听孩子才肯说 8.9 (2392人评价) 作者: [美]阿黛尔•法伯 伊莱恩•玛兹丽施 出版社: 中央编译出版社 出版年: 2007-11 评语：网上交口赞誉，很好读的亲子沟通读本。 如何说孩子才肯学 8.5 (264人评价) 作者: 阿黛尔·法伯 / 伊莱恩·玛兹丽施 出版社: 中央编译出版社 出版年: 2008.4 评语：与“如何说孩子才会听”同一作者 如何说孩子才能和平相处 8.9 (48人评价) 作者: [美] 阿黛尔·法伯 / [美] 伊莱恩·玛兹丽施 著 / [美] 肯伯利·安·蔻 插图 出版社: 中国商业出版社 出版年: 2010-1 评语：如何应对兄弟姐妹间和同伴冲突 如何说青少年才会听，怎么听青少年才肯说 8.3 (18人评价) 作者: 阿黛尔•法伯 / 伊莱恩•玛兹丽施 出版社: 高等教育出版社 出版年: 2008-11 评语：如何与青少年沟通 幸福的婚姻 8.5 (490人评价) 作者: [美] 约翰·戈特曼 / [美] 娜恩·西尔弗 出版社: 浙江人民出版社 出版年: 2014-2 评语：家庭和睦是教养的后院。后院起火，什么教养理念和方法都谈不上了。本书着力于如何改善夫妻关系，改善家庭生态，为戈特曼名作。自然，夫妻间的相处之道也是孩子人际学习的模版。 从出生到3岁 8.6 (404人评价) 作者: [美]伯顿·L·怀特（(Burton L.White） 出版社: 京华出版社 出版年: 2007-2 评语：陈忻博士推荐。经典图书，她推荐为0-3岁的首选 孩子，把你的手给我 8.8 (1290人评价) 作者: [美] 海姆·G.吉诺特 出版社: 京华出版社 出版年: 2004-9 评语：吉诺特著作。吉诺特作为先行者和倡导者，他的洞察，给很多后来者以很深的启发。 成为优秀父母的十大法则 8.0 (10人评价) 作者: 劳伦斯·斯坦伯格 出版社: 北京大学出版社 出版年: 2006-4 评语：通用法则类，非常好。作者曾任美国青少年心理协会会长，专注于青少年心理。 孩子，你的情绪我在乎 8.3 (27人评价) 作者: 约翰•戈特曼 出版社: 沈阳出版社 出版年: 2011-10 评语：这本书是韩国人写的，用的是戈特曼的理论。应该说情境很东亚，写的也挺好读。不过“干货”只有那么多，文字也不够简练（有点水分）。 管教有方 8.7 (21人评价) 作者: 简·尼尔森 出版社: 天津社科院 出版年: 2010-8 评语：为正面管教的同一作者，适合孩子为3-7岁的家长。以阿德勒理论为基础。 有话慢慢说 (1人评价) 作者: 汉恩·吉诺特 出版年: 2009-1 评语：吉诺特著作，与青少年沟通 关键教养报告 8.2 (69人评价) 作者: 波•布朗森 (Po Bronson) / 阿什利•梅里曼 (Ashley Merryman) 出版社: 浙江人民出版社 出版年: 2013-7-1 评语：介绍了很多当代心理学研究成果对教养的启发，很好读，不过个别章节为追求戏剧性稍有夸张。 让孩子的大脑自由 8.7 (439人评价) 作者: （美）约翰•梅迪纳 出版社: 浙江人民出版社 出版年: 2012-6 评语：介绍了不少新研究，有些类似《关键教养报告》 意志力 8.1 (2870人评价) 作者: [美] 罗伊·鲍迈斯特 / [美] 约翰·蒂尔尼 出版社: 中信出版社 出版年: 2012-6 评语：虽然并非教养读物，但关于意志力/自控力的规律是一样的。家长了解意志力，有助于提升自己和儿童的意志力。本书只有一章讲在育儿中如何提高孩子的意志力。 自控力 8.3 (24987人评价) 作者: [美] 凯利·麦格尼格尔 出版社: 文化发展出版社(原印刷工业出版社) 出版年: 2012-8 评语：虽然并非教养读物，但关于意志力/自控力的规律是一样的。家长了解意志力，有助于提升自己和儿童的意志力。本书没有专门章节谈在育儿中如何提高孩子的意志力。 教出乐观的孩子 8.3 (276人评价) 作者: 【美】马丁•塞利格曼 出版社: 万卷出版公司 出版年: 20100920 评语：如题，作者是乐观的著名研究者 安静 8.1 (1497人评价) 作者: 苏珊•凯恩 出版社: 中信出版社 出版年: 2012-9-1 评语：虽然并非教养读物，但有助于理解内向性格的来龙去脉。本书只有部分章节谈育儿中如何引导内向孩子 快乐交朋友 (1人评价) 作者: 米歇尔·波巴 出版社: 华东师大 出版年: 2011-5 评语：儿童在同伴关系遇到问题，不同情境下该怎么办。参考图书 打造儿童阅读环境 8.4 (87人评价) 作者: 艾登·钱伯斯 出版社: 南海出版公司 出版年: 2007-10 评语：如题，如何营造儿童良好的阅读环境+如何引导孩子爱上阅读，精彩，有指导性。 婴儿、儿童和青少年 9.1 (43人评价) 作者: [美]劳拉·E.贝克 出版社: 上海人民 出版年: 2008-11 评语：陈忻博士推荐，很有影响的儿童心理学教材。 故事知道怎么办 8.4 (233人评价) 作者: (澳大利亚)苏珊·佩罗 出版社: 天津教育出版社 出版年: 2011-8 评语：如何用故事帮助孩子成长和改变 解放父母解放孩子 8.9 (86人评价) 作者: [美] 阿黛尔•法伯和伊莱恩•玛兹丽施 著 出版社: 中国长安出版社 出版年: 2011-8","categories":[{"name":"教育","slug":"教育","permalink":"https://dxsm.github.io/categories/%E6%95%99%E8%82%B2/"}],"tags":[{"name":"儿童教育","slug":"儿童教育","permalink":"https://dxsm.github.io/tags/%E5%84%BF%E7%AB%A5%E6%95%99%E8%82%B2/"},{"name":"书籍","slug":"书籍","permalink":"https://dxsm.github.io/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"markdown参考案例","slug":"markdown_ref_nc","date":"2018-09-22T14:50:00.000Z","updated":"2020-04-11T15:46:05.564Z","comments":true,"path":"p/markdown-ref-nc.html","link":"","permalink":"https://dxsm.github.io/p/markdown-ref-nc.html","excerpt":"字符效果和横线等 删除线 斜体字 斜体字 粗体 粗体 粗斜体 粗斜体 高亮 上标：X2 下标：O2 脚注 Content [1]","text":"字符效果和横线等 删除线 斜体字 斜体字 粗体 粗体 粗斜体 粗斜体 高亮 上标：X2 下标：O2 脚注 Content [1] 缩写(同HTML的abbr标签) The HTML specification is maintained by the W3C. 引用 Blockquotes 引用的行内混合 Blockquotes 引用：如果想要插入空白换行即&lt;br /&gt;标签，在插入处先键入两个以上的空格然后回车即可，普通链接。 苹果 香蕉 锚点与链接 Links 普通链接 普通链接带标题 直接链接：https://github.com 锚点链接 mailto:test.test@gmail.com GFM a-tail link @pandao 邮箱地址自动链接 test.test@gmail.com www@vip.qq.com 多语言代码高亮 Codes 行内代码 Inline code 执行命令：npm install marked 缩进风格 即缩进四个空格，也做为实现类似 &lt;pre&gt; 预格式化文本 ( Preformatted Text ) 的功能。 &lt;?php echo &quot;Hello world!&quot;; ?&gt; 预格式化文本： | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | JS代码 function test() { console.log(\"Hello world!\"); } (function(){ var box = function() { return box.fn.init(); }; box.prototype = box.fn = { init : function(){ console.log('box.init()'); return this; }, add : function(str) { alert(\"add\", str); return this; }, remove : function(str) { alert(\"remove\", str); return this; } }; box.fn.init.prototype = box.fn; window.box =box; })(); var testBox = box(); testBox.add(\"jQuery\").remove(\"jQuery\"); 图片 Images 列表 Lists 无序列表（加号和嵌套）Unordered Lists (+/-/*) 列表1 列表2 列表二-1 列表二-2 列表二-3 level 3 list 列表3 列表一 列表二 有序列表 Ordered Lists (1./2.) 第一行 第二行 第三行 GFM task list GFM task list 1 GFM task list 2 GFM task list 3 GFM task list 3-1 GFM task list 3-2 GFM task list 3-3 GFM task list 4 GFM task list 4-1 GFM task list 4-2 绘制表格 Tables Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 特殊符号 HTML Entities Codes © &amp; ¨ ™ ¡ £ &amp; &lt; &gt; ¥ € ® ± ¶ § ¦ ¯ « · X² Y³ ¾ ¼ × ÷ » 18ºC &quot; ' Emoji表情 😃 😃 😂 @mentions, ⭐️ #refs, links, formatting, and tags supported 💘; list syntax required (any unordered or ordered list supported) ⏰; ♥️ 💛 💝 this is a complete item 👍 👎; this is an incomplete item test link 💊 💉 @pandao 📜 📁 📂; ⚙️ this is an incomplete item 🔍 🔒 ✉️ 📌 📎 📝 📆 📅 ; ⚡️ this is an incomplete item test link 🎉 🔔 ⏳; 🐰 ❓ ❗️ 🔖 📚 🔥 this is 🎶 ☀️ 🍄 an incomplete item test link; 🍵 🍎 🏠 🇨🇳 ▶️ ☑️ 🔗 :fa-gear: :fa-gear: ⚡️ 科学公式 TeX(KaTeX) E=mc2E=mc^2 E=mc2 行内的公式E=mc2E=mc^2E=mc2行内的公式，行内的E=mc2E=mc^2E=mc2公式。 x&gt;yx &gt; y x&gt;y (3x−1+(1+x)2)(\\sqrt{3x-1}+(1+x)^2) (3x−1​+(1+x)2) sin⁡(α)θ=∑i=0n(xi+cos⁡(f))\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f)) sin(α)θ=i=0∑n​(xi+cos(f)) 拓展功能–自定义div detail折叠 Python code import os print(\"hello world\") hint块 hello world hello world hello world hello world pannel块 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 任务列表 买一双运动鞋 背诵一篇作文 打一会篮球 绘制流程图 Flowchart 流程图语法参考 https://github.com/adrai/flowchart.js Markdown常用的元素有以下几种： start end operation condition inputoutput subroutine st=&gt;start: Start:&gt;https://dxsm.github.io[blank] e=&gt;end:&gt;https://dxsm.github.io op1=&gt;operation: My Operation sub1=&gt;subroutine: My Subroutine cond=&gt;condition: Yes or No?:&gt;https://dxsm.github.io io=&gt;inputoutput: catch something... para=&gt;parallel: parallel tasks st-&gt;op1-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;para para(path1, bottom)-&gt;sub1(right)-&gt;op1 para(path2, top)-&gt;op1 状态标记 Markdown会使用不同的颜色来标记状态，状态主要有以下几种： past current future approved rejected invalid start=&gt;start: 开始|past requirementAnalysis=&gt;operation: 需求分析|past design=&gt;operation: 软件设计|past coding=&gt;operation: 编码|past selfTestingPased=&gt;condition: 自测通过？|approved debug=&gt;operation: debug|invalid submitTestingPased=&gt;condition: 提测通过？|rejected modifyBug=&gt;operation: 修bug|current deploy=&gt;operation: 部署|future end=&gt;end: 结束|future start-&gt;requirementAnalysis-&gt;design-&gt;coding-&gt;selfTestingPased selfTestingPased(no)-&gt;debug(right)-&gt;selfTestingPased selfTestingPased(yes)-&gt;submitTestingPased submitTestingPased(yes)-&gt;deploy-&gt;end submitTestingPased(no)-&gt;modifyBug(right)-&gt;submitTestingPased Sequence Diagram 语法参考 https://bramp.github.io/js-sequence-diagrams/ Andrew-&gt;China: Says Hello Note right of China: China thinks\\nabout it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! mermaid mermaid非常强大，基本能够替代上面两种流程图，语法参考 https://mermaid-js.github.io/mermaid/#/flowchart sequence diagram sequenceDiagram Alice -&gt;&gt; Bob: Hello Bob, how are you? Bob--&gt;&gt;John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row. Bob--&gt;Alice: Checking with John... Alice-&gt;John: Yes... John, how are you? flowchart graph LR A[Square Rect] -- Link text --&gt; B((Circle)) A --&gt; C(Round Rect) B --&gt; D{Rhombus} C --&gt; D state diagram stateDiagram [*] --&gt; Still Still --&gt; [*] Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] pie chart pie title Pets adopted by volunteers &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 15 gantt gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d 电路时序图 clkdatheadbodytaildatareqack 思维导图 height: 200px #主题 ##论点1 ###概述1 ###概述2 ##论点2 ##论点3 ##论点4 我是脚注 ↩︎","categories":[{"name":"markdown","slug":"markdown","permalink":"https://dxsm.github.io/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://dxsm.github.io/tags/markdown/"}]}]}